<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库与死锁]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁定义 所谓死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 产生死锁的必要条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 处理死锁的基本方式 预防死锁。这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。 预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 避免死锁。该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。 检测死锁。这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。 但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。 解除死锁。这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。 常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。 死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。 如何查看MySQL数据库的死锁日志 登录MySQL 1mysql -h xxxx.xxx.xxx -P 3306 -u username -p 查看MySQL数据库的死锁信息 1show engine innodb status \G; 找到“LATEST DETECTED DEADLOCK”一节内容。 查看当前的事务 1SELECT * FROM information_schema.innodb_trx \G; 查看当前锁定的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 查看当前等锁的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 查在抢资源进程 1SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; 杀掉它们 1Kill trx_mysql_thread_id; 参考1参考2]]></content>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类区别]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类 abstract class 抽象类是指在 class 前加了 abstract 关键字且存在抽象方法（在类方法 function 关键字前加了 abstract 关键字）的类。 抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。 如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。 如果 B 实现了 A 的抽象方法 abstract_func() ，那么 B 中 abstract_func() 方法的访问控制不能比 A 中 abstract_func() 的访问控制更严格。 接口 interface 抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字 interface 来声明。 interface 是完全抽象的，只能声明方法，而且只能声明 public 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也不能声明实例变量 。 然而， interface 却可以声明常量变量 。但将常量变量放在 interface 中违背了其作为接口的作用而存在的宗旨，也混淆了 interface 与类的不同价值。 如果的确需要，可以将其放在相应的 abstract class 或 Class 中。 任何实现接口的类都要实现接口中所定义的所有方法，否则该类必须声明为 abstract 。 一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。 一个类可以同时继承一个父类和实现任意多个接口。 extends 子句应该在 implements 子句之前。 PHP 只支持继承自一个父类，因此 extends 关键字后只能跟一个类名。 接口不可以实现另一个接口，但可以继承多个。 抽象类和接口的异同 相同点： (1) 两者都是抽象类，都不能实例化。 (2) interface 实现类及 abstract class 的子类都必须要实现已经声明的抽象方法。 不同点： (1) interface 需要实现，要用 implements ，而 abstract class 需要继承，要用 extends 。 (2) 一个类可以实现多个 interface ，但一个类只能继承一个 abstract class 。 (3) interface 强调特定功能的实现，而 abstract class 强调所属关系。 (4) 尽管 interface 实现类及 abstract class 的子类都必须要实现相应的抽象方法，但实现的形式不同。 interface 中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体 ) ，实现类必须要实现。而 abstract class 的子类可以有选择地实现。这个选择有两点含义： a) abstract class 中并非所有的方法都是抽象的，只有那些冠有 abstract 的方法才是抽象的，子类必须实现。那些没有 abstract 的方法，在 abstract class 中必须定义方法体； b) abstract class 的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。 (5) abstract class 是 interface 与 class 的中介。 abstract class 在 interface 及 class 中起到了承上启下的作用。一方面， abstract class 是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。 (6) 接口中的抽象方法前不用也不能加 abstract 关键字，默认隐式就是抽象方法，也不能加 final 关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上 abstract 表示显示声明为抽象方法。 (7) 接口中的抽象方法默认是 public 的，也只能是 public 的，不能用 private ， protected 修饰符修饰。而抽象类中的抽象方法则可以用 public ， protected 来修饰，但不能用 private 。 (8) 抽象类的继承是is a的关系。定义该体系的基本共性内容。接口的实现是like a的关系。定义体系的额外功能。 interface 的应用场合 (1) 类与类之间需要特定的接口进行协调，而不在乎其如何实现。 (2) 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。 (3) 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。 (4) 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。 abstract class 的应用场合 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有： (1) 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用 abstract class 定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。 (2) 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。 abstract 的中介作用可以很好地满足这一点。 (3) 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特 定的功能 。 参考1]]></content>
  </entry>
  <entry>
    <title><![CDATA[手机号归属地查询接口]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%89%8B%E6%9C%BA%E5%8F%B7%E5%BD%92%E5%B1%9E%E5%9C%B0%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[淘宝网 1234API地址： http:``//tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=15850781443参数：tel：手机号码返回：JSON 拍拍 123456API地址： http:``//virtual.paipai.com/extinfo/GetMobileProductInfo?mobile=15850781443&amp;amount=10000&amp;callname=getPhoneNumInfoExtCallback参数：mobile：手机号码callname：回调函数amount：未知（必须）返回：JSON 财付通 1234API地址： http:``//life.tenpay.com/cgi-bin/mobile/MobileQueryAttribution.cgi?chgmobile=15850781443参数：chgmobile：手机号码返回：xml 百付宝 123456API地址： https:``//www.baifubao.com/callback?cmd=1059&amp;callback=phone&amp;phone=15850781443参数：phone：手机号码callback：回调函数cmd：未知（必须）返回：JSON 有道api接口 12345678910111213141516接口地址：http:``//www.youdao.com/smartresult-xml/search.s?type=mobile&amp;q=13892101112参数说明：type ： 参数手机归属地固定为mobileq ： 手机号码返回XML格式：&lt;?xml version=``&quot;1.0&quot;``encoding=``&quot;gbk&quot;``?&gt;&lt;smartresult&gt;&lt;product type=``&quot;mobile&quot;``&gt;&lt;phonenum&gt;13892101112&lt;/phonenum&gt;&lt;location&gt;陕西 延安&lt;/location&gt;&lt;/product&gt;&lt;/smartresult&gt;或者http:``//www.youdao.com/smartresult-xml/search.s?jsFlag=true&amp;type=mobile&amp;q=手机号码返回JSON格式：fYodaoCallBack(1, &#123;‘product’:``&apos;mobile’,&apos;``phonenum’:’13892101112′,’location’:&apos;陕西 延安’&#125; , ”); 096.me api接口 12http:``//www.096.me/api.php?phone=手机号&amp;mode=&#123;txt,xml&#125;举例：http:``//www.096.me/api.php?phone=13892101111&amp;mode=txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[移位运算]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[逻辑左移时，最高位丢失，最低位补0； 逻辑右移时，最高位补0，最低位丢失； 算术左移时，依次左移一位，尾部补0，最高的符号位保持不变。 算术右移时，依次右移一位，尾部丢失，符号位右移后，原位置上复制一个符号位； 循环左移时，将最高位重新放置最低位 循环右移时，将最低位重新放置最高位 例如： 1010100010101 逻辑左移一位结果为 0101000101010 逻辑右移一位结果为 0101010001010 算术左移一位结果为 1101000101010 算术右移一位结果为 1101010001010 循环左移一位结果为 0101000101011 循环右移一位结果为 1101010001010]]></content>
  </entry>
  <entry>
    <title><![CDATA[macOS环境部署Hexo]]></title>
    <url>%2F2018%2F08%2F29%2FmacOS%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2Hexo%2F</url>
    <content type="text"><![CDATA[安装XcodeMac App Store下载安装 安装Node.js1234$ brew install nvm$ mkdir ~/.nvm$ export NVM_DIR=~/.nvm$ . $(brew --prefix nvm)/nvm.sh 安装Hexo123456npm install -g hexo-clicd ~/Desktop/hexo-bloghexo initnpm installhexo generatehexo server 打开 http://localhost:4000/ ，会看到效果。 部署Github仓库 cd到你的博客文件夹 vim _config.yml 加上如下 1234deploy: type: git repository: https://github.com/KevinCoderX/KevinCoderX.github.io.git branch: master 执行命令 123npm install hexo-deployer-git --savehexo generatehexo deploy 装饰你的博客1git clone https://github.com/theme-next/hexo-theme-next themes/next _config.yml里theme的名称修改为next 123hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 写下你的博客1hexo new post &quot;我的第一篇博客&quot; //名字可以自己取 参考1 参考2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用格式]]></title>
    <url>%2F2018%2F08%2F29%2FMarkdown%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[标题在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可。 注：# 和「一级标题」之间建议保留一个字符的空格。 列表在文字前面加上 - 就可以了。 也可以在文字前面加上 1. 2. 3。 注：-、1.和文本之间要保留一个字符的空格。 插入链接和图片插入链接使用 [显示文本](链接地址) 这样的语法即可。 插入图片只需要使用 ![](图片链接地址) 这样的语法即可。 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 引用在希望引用的文字前面加上 &gt; 就好了。 注：&gt; 和文本之间要保留一个字符的空格。 粗体和斜体用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 代码引用需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。 如果引用的语句为多行，可以将`置于这段代码的首行和末行。 表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 参考1 参考2 Markdown编辑器]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我有一头小毛驴，可是我从来都不骑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
