<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="where is this place ?">
<meta property="og:type" content="website">
<meta property="og:title" content="十二遥的破碎维度">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="十二遥的破碎维度">
<meta property="og:description" content="where is this place ?">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十二遥的破碎维度">
<meta name="twitter:description" content="where is this place ?">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>十二遥的破碎维度</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">十二遥的破碎维度</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/高性能mysql第四章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/高性能mysql第四章/" itemprop="url">
                  高性能mysql第四章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-26 15:02:00 / Modified: 15:09:49" itemprop="dateCreated datePublished" datetime="2019-11-26T15:02:00+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第4章-Schema与数据类型优化"><a href="#第4章-Schema与数据类型优化" class="headerlink" title="第4章 Schema与数据类型优化"></a>第4章 Schema与数据类型优化</h1><p>良好的逻辑设计和物理设计是高性能的基石。</p>
<h2 id="4-1-选择优化的数据类型"><a href="#4-1-选择优化的数据类型" class="headerlink" title="4.1 选择优化的数据类型"></a>4.1 选择优化的数据类型</h2><p>更小的通常更好</p>
<p>简单就好：整型比字符操作代价更低，应该使用MySQL内建的类型而不是字符串来存储日期和时间，应该用整型存储IP地址</p>
<p>尽量避免NULL：如果查询中包含可为NULL的列，MySQL更难优化，因为可为NULL的列使得索引，索引统计和值的比较都更加复杂。NULL还会使用更多的存储空间</p>
<h3 id="4-1-1-整数类型"><a href="#4-1-1-整数类型" class="headerlink" title="4.1.1 整数类型"></a>4.1.1 整数类型</h3><p>整型类型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT，分别使用8，16，24，32，64位存储空间。</p>
<p>UNSIGNED属性，表示不可为负。有符号和无符号使用同样的存储空间，同样的性能。</p>
<p>可以为整数类型指定宽度，如INT（11），但大多数应用这样是没有意义的，它不会限制值的合法范围，只规定了MySQL的一些交互工具用来显示字符的个数。</p>
<h3 id="4-1-2-实数类型"><a href="#4-1-2-实数类型" class="headerlink" title="4.1.2 实数类型"></a>4.1.2 实数类型</h3><p>FLOAT，4个字节，DOUBLE，8个字节。还可以使用DECIMAL存储比BIGINT还大的整数。</p>
<p>MySQL使用DOUBLE作为内部浮点计算的类型</p>
<p>因为需要额外的空间和计算开销，应该尽量只在对小数进行精确计算时才使用DECIMAL</p>
<h3 id="4-1-3-字符串类型"><a href="#4-1-3-字符串类型" class="headerlink" title="4.1.3 字符串类型"></a>4.1.3 字符串类型</h3><p>VARCHAR和CHAR</p>
<p>VARCHAR：用于存储可变长字符串，比定长类型更节省空间。例外：当MySQL表使用ROW_FORMAT=FIXED创建时，每一行都会使用定长存储。</p>
<p>VARCHAR需要1或者2个额外字节记录字符串长度：列最大长度小于等于255字节，则为1，否则为2</p>
<p>由于行是变长的，在UPDATE使得行比原来长时，导致需要额外的工作。</p>
<p>VARCHAR（5）和VARCHAR（200）在存储‘hello’时，空间开销是一样的，但更短的列的优势在于会消耗更小的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。特别是使用内存临时表进行排序或操作时。</p>
<p>CHAR：定长的，会根据定义的字符串长度分配足够的空间。适合存储很短的字符串，或者所有值都接近同一个长度。如MD5值，或经常变更的数据，因为不容易产生碎片。对于非常短的列，如一列，CHAR只需要一个字节，VARCHAR需要两个字节，另一个字节需要记录长度。</p>
<p>BLOB和TEXT</p>
<p>BLOB和TEXT都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>MySQL会把每个BLOB和TEXT值当作一个独立的对象处理，当值太大时，InnoDB会使用专门的外部存储区域来存储，此时行内需要1～4个字节存储一个指针，指向外部存储区域。</p>
<p>BLOB和TEXT仅有的区别就是BLOB存储的是二进制数据，没有排序规则或字符集。</p>
<p>MySQL对BLOB和TEXT列进行排序时，只会对每个列的前max_sort_length字节排序。</p>
<p>因为Memory引擎不支持BLOB和TEXT，当查询使用了这两个类型，并且需要建临时表时，不得不使用MyISAM磁盘临时表，即使只有几行数据。这会导致严重的性能开销。</p>
<p>最好的解决方案是避免使用BLOB和TEXT类型，不得不使用的时候，在所有用到的地方使用SUBSTRING（column，length）将列转换成字符串。这样就可以使用内存临时表。</p>
<p>使用枚举（ENUM）代替字符串类型</p>
<p>MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。因为MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”的映射关系。</p>
<p>所以如果使用数字作为ENUM枚举常量可能会造成混乱</p>
<p>还有一点，枚举字段时按照内部存储的整数，而不是定义的字符串进行排序，所以绕过这种限制的方式是按照需要的顺序定义枚举列。</p>
<p>枚举最不好的地方就在于，字符串列表是固定的，添加或删除字符串必须使用ALERT TABLE。</p>
<p>由于枚举被保存为整数，必须进行查找才能转换成字符串，所以会有一些开销。特定情况下，字符串列与枚举列关联可能比直接关联字符串更慢。</p>
<h3 id="4-1-4-日期和时间类型"><a href="#4-1-4-日期和时间类型" class="headerlink" title="4.1.4 日期和时间类型"></a>4.1.4 日期和时间类型</h3><p>MySQL能存储的最小时间粒度为秒。</p>
<p>DATATIME：能保存大范围的值，从1001年到9999年。与时区无关。使用8个字节存储空间。</p>
<p>TIMESTAMP：保存从1970年1月1日开始的秒数，最大只能到2038年。使用4个字节存储空间。显示的值依赖时区。默认为NOT NULL。</p>
<h3 id="4-1-5-位数据类型"><a href="#4-1-5-位数据类型" class="headerlink" title="4.1.5 位数据类型"></a>4.1.5 位数据类型</h3><p>BIT：避免使用。因为MySQL把BIT当作字符串类型，但在数字上下文场景，又会将字符串转换成数字。如‘00111001’（二进制值等于57）存储到BIT（8）的列并检索时，得到ASCII码为57的字符“9”，但当与0做加法运算时，得到的是数字57，这很费解。</p>
<p>SET：当需要保存很多true/false值时，可以考虑合并这些列到一个SET类型。因为它在MySQL内部是以一系列打包的位的集合来表示，可以有效利用存储空间。缺点是改变列的定义必须使用ALERT TABLE，代价很高。一般情况下，也无法在SET列上进行索引查找。</p>
<p>在整数列上进行按位操作：比如把8个位包装到一个TINYINT中，并且按位操作来使用。</p>
<h3 id="4-1-6-选择标识符（identifier）"><a href="#4-1-6-选择标识符（identifier）" class="headerlink" title="4.1.6 选择标识符（identifier）"></a>4.1.6 选择标识符（identifier）</h3><p>整数累通常是标识列最好的选择。因为它们很快，并且可以使用AUTO_INCREMENT</p>
<h3 id="4-1-7-特殊数据类型"><a href="#4-1-7-特殊数据类型" class="headerlink" title="4.1.7 特殊数据类型"></a>4.1.7 特殊数据类型</h3><p>低于秒级精度的时间或者IPv4地址。人们经常使用VARCHAR（15）列来存储IP地址，但是它实际上是32位无符号整数，小数点分成四段只是为了人们阅读容易。应该使用无符号整数存储IP，MySQL提供了INET_ATON（）和INET_NTOA函数来进行转换。</p>
<h2 id="4-2-MySQL-schema设计中的陷阱"><a href="#4-2-MySQL-schema设计中的陷阱" class="headerlink" title="4.2 MySQL schema设计中的陷阱"></a>4.2 MySQL schema设计中的陷阱</h2><p>太多的列：</p>
<pre><code>MySQL的存储引擎API工作时，需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务层将缓冲内容解码成各个列。将编码过的列转换成行数据结构的操作代价是非常高的。

定长MyISAM行结构与上册服务器层行结构正好匹配，不需要转换，变成的行结构和InnoDB的行结构则总是需要转换。
</code></pre><p>太多的关联：</p>
<pre><code>MySQL限制了每个关联操作最多只能有61张表。
</code></pre><p>全能的枚举：</p>
<pre><code>在MySQL中，当为枚举列表做新增操作时，需要用ALERT TABLE操作，而ALERT TABLE是一种阻塞操作。
</code></pre><p>变相的枚举：</p>
<pre><code>SET当枚举用，可能造成混乱
</code></pre><p>非此发明的NULL</p>
<pre><code>虽然需要避免使用NULL，并在需要存储一个事实上的空值到表里时，可以使用0，某个特殊值，或者空字符串。但是也不要走极端，比如用-1代替一个未知的整数，可能会导致代码复杂，还不如用NULL。
</code></pre><h2 id="4-3-范式和反范式"><a href="#4-3-范式和反范式" class="headerlink" title="4.3 范式和反范式"></a>4.3 范式和反范式</h2><p>在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能存储在多个地方。</p>
<h3 id="4-3-1-范式的优点和缺点"><a href="#4-3-1-范式的优点和缺点" class="headerlink" title="4.3.1 范式的优点和缺点"></a>4.3.1 范式的优点和缺点</h3><p>当为性能问题，尤其是写场景密集，寻求帮助时，通常被建议对schema进行范式化设计。</p>
<p>优点：<br>    范式化更新操作通常比反范式化要快，且只需要修改更少的数据。<br>    范式化的表通常更小，可以更好的放在内存里，执行操作会更快<br>    很少的多余数据意味着更少需要DISTINCT或者GROUP BY语句</p>
<p>缺点：通常需要关联，可能使一些索引策略失效</p>
<h3 id="4-3-2-反范式的优点和缺点"><a href="#4-3-2-反范式的优点和缺点" class="headerlink" title="4.3.2 反范式的优点和缺点"></a>4.3.2 反范式的优点和缺点</h3><p>避免关联。</p>
<h3 id="4-3-3-混用范式化和反范式化"><a href="#4-3-3-混用范式化和反范式化" class="headerlink" title="4.3.3 混用范式化和反范式化"></a>4.3.3 混用范式化和反范式化</h3><p>实际应用中不存在极端的范式和反范式，经常需要混用。</p>
<h2 id="4-4-缓存表和汇总表"><a href="#4-4-缓存表和汇总表" class="headerlink" title="4.4 缓存表和汇总表"></a>4.4 缓存表和汇总表</h2><p>创建一张完全独立的汇总表或缓存表。缓存表存储可以从schema其他表获取，但每次获取速度都比较慢的数据，汇总表存储使用GROUP BY语句聚合的数据。</p>
<p>通过原子重命名操作，切换影子表和原表</p>
<p>CREATE TABLE table_new LIKE table；<br>RENAME TABLE table TO table_old，table_new TO table；</p>
<h3 id="4-4-1-物化视图"><a href="#4-4-1-物化视图" class="headerlink" title="4.4.1 物化视图"></a>4.4.1 物化视图</h3><p>物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。</p>
<h3 id="4-4-2-计数器表"><a href="#4-4-2-计数器表" class="headerlink" title="4.4.2 计数器表"></a>4.4.2 计数器表</h3><p>注意并发问题。</p>
<h2 id="4-5-加快ALERT-TABLE操作的速度"><a href="#4-5-加快ALERT-TABLE操作的速度" class="headerlink" title="4.5 加快ALERT TABLE操作的速度"></a>4.5 加快ALERT TABLE操作的速度</h2><p>MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。</p>
<p>一般而言，大部分ALERT TABLE操作将导致MySQL服务中断。</p>
<p>两个技巧：在一台不提供服务的机器上执行ALERT TABLE，然后和提供服务的主库进行切换。另一个是影子拷贝。</p>
<p>并不是所有ALERT TABLE都会重建表。用ALERT TABLE修改表默认值的时候会重建，但其实可以直接修改.frm文件，而ALERT COLUMN就是这样做的，不会重建表。</p>
<h3 id="4-5-1-只修改-frm文件"><a href="#4-5-1-只修改-frm文件" class="headerlink" title="4.5.1 只修改.frm文件"></a>4.5.1 只修改.frm文件</h3><p>下面这些操作是有可能不需要重建表的：<br>    移除（不是增加）一个列的AUTO_INCREMENT属性<br>    增加，移除或者更改ENUM和SET常量</p>
<p>通过创建一个新的.frm文件，替换掉原来的.frm文件:<br>    创建有同样结构的空表，并进行修改<br>    执行 FLUSH TABLE WITH READ LOCK，将会关闭所有正在使用的表，并且禁止任何表被打开<br>    交换.frm文件<br>    执行UNLOCK TABLES来释放锁</p>
<h3 id="4-5-2-快速创建MyISAM索引"><a href="#4-5-2-快速创建MyISAM索引" class="headerlink" title="4.5.2 快速创建MyISAM索引"></a>4.5.2 快速创建MyISAM索引</h3><p>通过先禁用索引，载入数据，再重启索引</p>
<p>ALERT TABLE table DISABLE KEYS;<br>—load data<br>ALERT TABLE table ENABLE KEYS;</p>
<p>原因是构建索引的工作被延迟到数据完全载入后，这个时候可以通过排序来构建索引，会快很多，并且使索引数的碎片更少，更紧凑。</p>
<p>但是对唯一索引无效。MyISAM会在内存中构建唯一索引，检查载入的每一行的唯一性。</p>
<h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p>尽可能保持小而简单：避免过度设计，使用小而简单的数据类型，尽量避免使用NULL，使用相同的数据类型存储相似或者相关的值，注意可变长字符串，尽量使用整型定义标识符，避免使用MySQL已经遗弃的特效，小心使用ENUM和SET。最好避免使用BIT</p>
<p>范式很好，但有时反范式很有必要。</p>
<p>ALERT TABLE操作很痛苦。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/高性能mysql第三章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/高性能mysql第三章/" itemprop="url">
                  高性能mysql第三章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-26 15:01:55 / Modified: 15:07:25" itemprop="dateCreated datePublished" datetime="2019-11-26T15:01:55+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第3章-服务器性能剖析"><a href="#第3章-服务器性能剖析" class="headerlink" title="第3章 服务器性能剖析"></a>第3章 服务器性能剖析</h1><p>使用性能剖析，专注于测试服务器的时间花费在哪里，以达到优化整机性能，优化单条语句执行速度以及诊断或者解决那些很难观察到的问题。</p>
<h2 id="3-1-性能优化简介"><a href="#3-1-性能优化简介" class="headerlink" title="3.1 性能优化简介"></a>3.1 性能优化简介</h2><p>这里将性能定义为完成某件任务所需要的时间度量，将优化定义为在一定的工作负载下尽可能的降低响应时间。</p>
<p>无法测量就无法有效的优化</p>
<h3 id="3-1-1-通过性能剖析进行优化"><a href="#3-1-1-通过性能剖析进行优化" class="headerlink" title="3.1.1 通过性能剖析进行优化"></a>3.1.1 通过性能剖析进行优化</h3><p>两个步骤：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排在前面。</p>
<h3 id="3-1-2-理解性能剖析"><a href="#3-1-2-理解性能剖析" class="headerlink" title="3.1.2 理解性能剖析"></a>3.1.2 理解性能剖析</h3><p>性能剖析将最重要的任务展示在前面，但有时候没显示出来的信息也很重要。</p>
<p>（暂缺）</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/高性能mysql第二章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/高性能mysql第二章/" itemprop="url">
                  高性能mysql第二章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-26 15:01:51 / Modified: 15:06:45" itemprop="dateCreated datePublished" datetime="2019-11-26T15:01:51+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第2章-mysql基准测试"><a href="#第2章-mysql基准测试" class="headerlink" title="第2章 mysql基准测试"></a>第2章 mysql基准测试</h1><p>基准测试是针对系统设计的一种压力测试。</p>
<h2 id="2-1-为什么需要基准测试"><a href="#2-1-为什么需要基准测试" class="headerlink" title="2.1 为什么需要基准测试"></a>2.1 为什么需要基准测试</h2><p>基准测试是唯一方便有效的，可以学习系统在给定的工作负载下会发生什么的方法。</p>
<h2 id="2-2-基准测试的策略"><a href="#2-2-基准测试的策略" class="headerlink" title="2.2 基准测试的策略"></a>2.2 基准测试的策略</h2><p>两种主要策略：集成式是针对整个系统的整体测试。单组件式是单独测试MySql。</p>
<h3 id="2-2-1-测试何种指标"><a href="#2-2-1-测试何种指标" class="headerlink" title="2.2.1 测试何种指标"></a>2.2.1 测试何种指标</h3><p>吞吐量，响应时间或者延迟，并发性，可扩展性</p>
<h2 id="2-3-基准测试方法"><a href="#2-3-基准测试方法" class="headerlink" title="2.3 基准测试方法"></a>2.3 基准测试方法</h2><p>如果其他条件相同，就应努力使测试过程尽可能接近真实应用的情况。</p>
<h3 id="2-3-1-设计和规划基准测试"><a href="#2-3-1-设计和规划基准测试" class="headerlink" title="2.3.1 设计和规划基准测试"></a>2.3.1 设计和规划基准测试</h3><p>（暂停）</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/高性能mysql第一章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/高性能mysql第一章/" itemprop="url">
                  高性能mysql第一章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-26 15:01:46 / Modified: 15:06:02" itemprop="dateCreated datePublished" datetime="2019-11-26T15:01:46+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第1章-mysql架构与历史"><a href="#第1章-mysql架构与历史" class="headerlink" title="第1章 mysql架构与历史"></a>第1章 mysql架构与历史</h1><p>Mysql最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理及其他系统任务和数据存储/提取相分离。</p>
<h2 id="1-1-mysql逻辑架构"><a href="#1-1-mysql逻辑架构" class="headerlink" title="1.1 mysql逻辑架构"></a>1.1 mysql逻辑架构</h2><p>最上层，连接处理，授权认证，安全等<br>第二层，大多数mysql的核心服务功能都在这一层，包含查询解析，分析，优化，缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等<br>第三层，存储引擎，负责mysql中数据的存储和提取，通过API与上层通信</p>
<h3 id="1-1-1-连接管理与安全性"><a href="#1-1-1-连接管理与安全性" class="headerlink" title="1.1.1 连接管理与安全性"></a>1.1.1 连接管理与安全性</h3><p>每个客户端连接都会在服务器进程中拥有一个线程。当客服端连接时，服务器需对其进行基于用户名，原始主机信息和密码的认证。连接成功后，还会继续验证客户端权限。</p>
<h3 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h3><p>Mysql会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以通过特殊关键字（hint）提示优化器，影响决策，也可以请求优化器解释（explain）优化过程。</p>
<p>优化器虽然不关心使用什么存储引擎，但是会请求存储引擎提供容器或某个操作的开销信息，以及表数据的统计信息等。</p>
<p>对于select语句，在解析查询前，会先检查缓存。</p>
<h2 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h2><p>包括两个层面的并发控制：服务器层与存储引擎层。</p>
<h3 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h3><p>共享锁和排他锁，也叫读锁和写锁。</p>
<h3 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h3><p>一种提高共享资源并发性的方式，就是让锁定对象更有选择性（粒度更小），最理想的方式，是只对会修改的数据片进行精确锁定。然而加锁也需要消耗资源。</p>
<p>锁策略，就是在锁的开销和数据的安全性之间寻求平衡。mysql提供多种存储引擎，每种都可以实现自己的锁策略和锁粒度。</p>
<p>表锁：最基本的锁策略，也是开销最小的策略。mysql本身会使用各种有效的表锁，来实现不同的目的，而忽略存储引擎的锁机制。</p>
<p>行级锁：最大程度支持并发处理，同时带来最大的锁开销。行级锁只在存储引擎层实现 ，mysql服务层没有实现。</p>
<h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>事务就是一组原子性的sql查询。一个运行良好的事务处理系统，必须通过严格的ACID测试，ACID表示原子性（atomicity），一致性（consistency），隔离性（isolation）和持久性（durability）。</p>
<p>原子性：一个不可分割的最小工作单元，要么全部提交成功要不全部失败会滚。</p>
<p>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。（没有提交的事务，修改不会保存到数据库）</p>
<p>隔离性：通常来说，一个事务所做的修改，在最终提交以前，对其他事务是不可见的。</p>
<p>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。</p>
<h3 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h3><p>READ UNCOMMITTED（未提交读）：事务可以读取未提交的数据，也被称为脏读，实际应用中很少使用。</p>
<p>READ COMMITTED（提交读）：也叫不可重复读，大多数数据库默认隔离级别。</p>
<p>REPEATABLE READ（可重复读）：保证在同一个事务中多次读取相同记录的结果一致，解决了脏读的问题。但是没有解决幻读的问题。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读的问题。是mysql默认的事务隔离等级。</p>
<p>SERIALIZABLE（可串行化）：最高隔离等级，通过强制事务串行执行，避免了幻读问题。但是可能导致大量超时和锁争用的问题，实际应用中很少用到。</p>
<h3 id="1-3-2-死锁"><a href="#1-3-2-死锁" class="headerlink" title="1.3.2 死锁"></a>1.3.2 死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p>
<p>InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<h3 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h3><p>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久化磁盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。之后修改在后台慢慢刷回到磁盘。</p>
<p>如果数据修改记录到了事务日志并持久化，但是数据本身还没有写回磁盘，此时系统奔溃的话，存储引擎可以在重启时自动恢复这部分数据。具体方式视各存储引擎而定。</p>
<h3 id="1-3-4-mysql中的事务"><a href="#1-3-4-mysql中的事务" class="headerlink" title="1.3.4 mysql中的事务"></a>1.3.4 mysql中的事务</h3><p>Mysql提供两种事务性存储引擎：InnoDB和NDB Cluster。</p>
<p>自动提交：mysql默认采用自动提交模式，如果不是显式开始一个事务，则每个查询都被当作一个事务执行提交操作。</p>
<p>可以通过设置AUTOCOMMIT变量禁用自动提交模式，禁用后，所有的查询都是在一个事务中，直到显式执行COMMIT或者ROLLBACK。</p>
<p>还有一些命令，在执行前会强制执行COMMIT当前活动的事务。如ALERT TABLE，LOCK TABLES等</p>
<p>Mysql可以通过执行SET TRANSACTION ISOLATION LEVEL 来设计隔离级别。新的隔离级别将在下一个事务开始的时候生效。</p>
<p>在事务中混合使用存储引擎：不可靠，如果在事务中混合了事务型和非事务型表，如InnoDB和MyISAM，在正常提交下不会有问题，但是如果需要回滚，非事务型表上的数据无法撤销。</p>
<p>并且在非事务型表上执行事务相关操作时，mysql不会提示或者报错，唯一只有在回滚操作时有一个警告。</p>
<p>隐式和显式锁定：InnoDB采用两阶段锁定协议，在事务执行过程中，会根据隔离等级，在需要的时候自动添加隐式锁定，并在提交或者回滚操作的时候，同一时刻释放。在执行特定语句，如SELECT … LOCK IN SHARE MODE，SELECT … FOR UPDATE时，进行显示锁定。</p>
<p>注：不建议显式执行LOCK TABLES语句，无论使用什么存储引擎。不仅因为当表从MyISAM转换到InnoDB时，语句会严重影响性能，在与事务相互影响的时候，情况会非常复杂，根据mysql版本不同，也可能会产生无法预料的结果。</p>
<h2 id="1-4-多版本并发控制"><a href="#1-4-多版本并发控制" class="headerlink" title="1.4 多版本并发控制"></a>1.4 多版本并发控制</h2><p>基于提高并发性能的考虑，mysql大多数事务型存储引擎不仅实现了行级锁，还同时实现了多版本并发控制（MVCC）。</p>
<p>MVCC可以认为是行级锁的一个变种，在很多情况下避免了加锁操作，开销更低。</p>
<p>MVCC是通过保存数据在某个时间点的快照来实现。</p>
<p>InnoDB的MVCC：在每行记录后面保存两个隐藏列，一个保存行的创建时间，一个保存行的过期时间。存储的不是实际的时间，是系统的版本号。</p>
<p>SELECT：查找创建版本小于等于当前事务的系统版本号，删除版本要么未定义，要么大于当前事务系统版本号。保证读取的行，要么是事务开始之前就存在，或者是本事务的修改，并且在本事务开始前未被删除。</p>
<p>INSERT：为新插入的每一行保存当前系统版本号作为创建版本号。</p>
<p>DELETE：为删除的每一行保存当前系统版本号作为删除版本号。</p>
<p>UPDATE： 为插入一行新记录，保存当前系统版本号作为创建版本号，同时保存当前系统版本号到原来行作为行删除版本号。</p>
<p>保存两个额外的版本号，使得大多是读操作不需要加锁，使得读操作性能很好。缺点是每行需要额外的存储空间，更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC只在可重复读和提交读两个隔离等级下工作。</p>
<h2 id="1-5-mysql的存储引擎"><a href="#1-5-mysql的存储引擎" class="headerlink" title="1.5 mysql的存储引擎"></a>1.5 mysql的存储引擎</h2><p>Mysql将每个数据库（schema）保存在数据目录下的一个子目录，创建表时，在这个子目录下创建一个和表同名的.frm文件保存表的定义。大小写敏感和平台相关，表的定义在服务层统一处理。</p>
<p>可以使用SHOW TABLE STATUS命令查看表的相关信息。</p>
<h3 id="1-5-1-InoDB存储引擎"><a href="#1-5-1-InoDB存储引擎" class="headerlink" title="1.5.1 InoDB存储引擎"></a>1.5.1 InoDB存储引擎</h3><p>InoDB是mysql默认的事务型引擎，被设计用来处理大量短期事务，即大部分情况是正常提交，很少回滚的事务。</p>
<p>InnoDB的历史：Oracle主力开发，还有很多其他贡献者。</p>
<p>InnoDB概览：InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。</p>
<p>InnoDB采用MVCC来支持高并发，并且实现了四个标准隔离级别。默认级别是可重复读，并且通过间隙锁策略来防止幻读。间隙锁使得InnoDB不仅锁定查询涉及到的行，还会对索引中的间隙进行锁定。</p>
<p>InnoDB表是基于聚簇索引建立的，对主键查询有很高的性能。不过二级索引中必须包含主键列。</p>
<p>InnoDB内部做了很多优化。包括可预测性预读，自适应哈希索引，插入缓冲区等。</p>
<p>作为事务型存储引擎，InnoDB通过一些机制和工具，支持真正的热备份。</p>
<h3 id="1-5-2-MyISAM存储引擎"><a href="#1-5-2-MyISAM存储引擎" class="headerlink" title="1.5.2 MyISAM存储引擎"></a>1.5.2 MyISAM存储引擎</h3><p>在mysql 5.1 版本之前，MyISAM是默认存储引擎，提供了大量特性，包括全文索引，压缩，空间函数等。但是MyISAM不支持事务和行级锁，而且奔溃后无法安全恢复。</p>
<p>存储：MyISAM会将表存储在两个文件中，数据文件和索引文件，分别以.MYD和.MYI为扩张名。</p>
<p>MyISAM表可以包含动态或者静态（长度固定）行。会根据表的定义来决定采用何种行格式。可以存储的行记录数，一般受限于可用的磁盘空间或者操作系统中单文件最大尺寸。</p>
<p>在mysql5.0中，MyISAM如果时变长行，默认配置只能处理256TB数据。可以通过修改MAX_ROWS和AVG_ROW_LENGTH来改变，这两者相乘就是最大大小。（修改会导致重建整个表和表的所有索引，需要很长时间）</p>
<p>MyISAM特性：</p>
<pre><code>加锁与并发：MyISAM对整张表加锁，不针对行。读取时对所有读到的表加共享锁，写入时加排他锁。但是在读取时，也可以往表里插入新的记录（并发插入）

修复：对于MyISAM表，mysql可以手动或自动执行检查（CHECK TABLE mytable）和修复（REPPAIR TABLE mytable）操作。如果mysql服务器已经关闭，也可以通过myisamchk命令行工具。但是这里说的恢复和事务恢复以及崩溃恢复是不同的概念。

索引特性：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。也支持全文索引。

延迟更新索引键：创建MyISAM表时，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是写到内存中的键缓冲区，在清理缓冲区或关闭表时，才会写到磁盘。这样可以极大提高写入性能，但在数据库崩溃时会造成索引损坏，需要执行修复操作。

MyISAM压缩表：如果表在创建并导入数据后，不会再进行修改操作，那么可以采用压缩表。
</code></pre><p>使用myisampack进行压缩。压缩表不可进行修改，除非解压修改再压缩。可以极大减少磁盘空间占用和磁盘I/O，提高查询性能。压缩表的索引也是只读。</p>
<pre><code>性能：MyISAM引擎设计简单，数据以紧密格式存储，某些场景下性能很好。但是最大的性能问题还是表锁。
</code></pre><h3 id="1-5-3-MySQL内建的其他存储引擎"><a href="#1-5-3-MySQL内建的其他存储引擎" class="headerlink" title="1.5.3 MySQL内建的其他存储引擎"></a>1.5.3 MySQL内建的其他存储引擎</h3><p>Archive引擎，只支持INSERT和SELECT，没有索引。只适合日志和数据分析或者高速插入的场景。</p>
<p>Blackhole引擎，没有实现任何存储机制。不推荐。</p>
<p>CSV引擎，可以将CSV文件作为MySQL的表打开。不支持索引</p>
<p>Federated引擎，访问其他MySQL服务器的一个代理，因为经常带来问题，默认禁用。</p>
<p>Memory引擎，数据存在内存，不可修改，重启后表结构还在，但是数据丢失。读取的速度极快。但是时表级锁，并发写入性能差，不支持变长行长度，可能导致内存浪费。</p>
<p>MySQL在执行查询过程中需要临时表保存中间结果时，使用的临时表就是Memory表。但是如果中间结果太大吵过Memory表限制，会转换成M有ISAM表。故临时表和Memory表不能划等号。</p>
<p>Merge引擎：MyISAM引擎的变种，已经被放弃。</p>
<p>NDB集群引擎：NDB数据库的组合被称为MySQL集群。</p>
<h3 id="1-5-4-第三方存储引擎"><a href="#1-5-4-第三方存储引擎" class="headerlink" title="1.5.4 第三方存储引擎"></a>1.5.4 第三方存储引擎</h3><p>OLTP类引擎，面向列的存储引擎，社区存储引擎</p>
<h3 id="1-5-5-选择合适的引擎"><a href="#1-5-5-选择合适的引擎" class="headerlink" title="1.5.5 选择合适的引擎"></a>1.5.5 选择合适的引擎</h3><p>大部分情况下，InnoDB都是正确选择。</p>
<p>不要混合多种存储引擎。</p>
<h3 id="1-5-6-转换表的引擎"><a href="#1-5-6-转换表的引擎" class="headerlink" title="1.5.6 转换表的引擎"></a>1.5.6 转换表的引擎</h3><p>ALERT TABLE：适用任何存储引擎，但是需要执行很长时间。</p>
<p>导出与导入：适用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项。</p>
<p>创建于查询：先创建一个新的存储引擎表，然后利用INSERT…SELECT语法来导数据。</p>
<h2 id="1-6-MySQL时间线"><a href="#1-6-MySQL时间线" class="headerlink" title="1.6 MySQL时间线"></a>1.6 MySQL时间线</h2><p>略</p>
<h2 id="1-7-MySQL的开发模式"><a href="#1-7-MySQL的开发模式" class="headerlink" title="1.7 MySQL的开发模式"></a>1.7 MySQL的开发模式</h2><p>略</p>
<h2 id="1-8-总结"><a href="#1-8-总结" class="headerlink" title="1.8 总结"></a>1.8 总结</h2><p>MySQL拥有分层的架构，上层时服务器的服务和查询执行引擎，下层时存储引擎。能够理解MySQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MySQL的核心基础架构的精髓。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/高性能mysql第七章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/高性能mysql第七章/" itemprop="url">
                  高性能mysql第七章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-26 14:55:43" itemprop="dateCreated datePublished" datetime="2019-11-26T14:55:43+08:00">2019-11-26</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/高性能mysql第六章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/高性能mysql第六章/" itemprop="url">
                  高性能mysql第六章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-19 10:36:52" itemprop="dateCreated datePublished" datetime="2019-11-19T10:36:52+08:00">2019-11-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-11-26 14:53:06" itemprop="dateModified" datetime="2019-11-26T14:53:06+08:00">2019-11-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第6章-查询性能优化"><a href="#第6章-查询性能优化" class="headerlink" title="第6章 查询性能优化"></a>第6章 查询性能优化</h1><h2 id="6-1-为什么查询速度会慢"><a href="#6-1-为什么查询速度会慢" class="headerlink" title="6.1 为什么查询速度会慢"></a>6.1 为什么查询速度会慢</h2><p>通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。</p>
<h2 id="6-2-慢查询基础：优化数据访问"><a href="#6-2-慢查询基础：优化数据访问" class="headerlink" title="6.2 慢查询基础：优化数据访问"></a>6.2 慢查询基础：优化数据访问</h2><p>查询性能低下最基本的原因是访问的数据太多。</p>
<p>对于低效查询，先确认应用程序是否在检索大量超过需要的数据，再确认MySql服务器层是否在分析大量超过需要的数据行。</p>
<h3 id="6-2-1-是否向数据库请求了不需要的数据"><a href="#6-2-1-是否向数据库请求了不需要的数据" class="headerlink" title="6.2.1 是否向数据库请求了不需要的数据"></a>6.2.1 是否向数据库请求了不需要的数据</h3><p>请求超过实际需要的数据，然后多余的数据被应用程序丢弃，这会MySQL服务器带来额外的负担，并增加网络开销和应用服务器CPU和内存资源。</p>
<p>典型案例：</p>
<ul>
<li><p>查询不需要的记录</p>
</li>
<li><p>多表关联时返回全部列</p>
</li>
<li><p>总是取出全部列</p>
</li>
<li><p>重复查询相同的数据</p>
</li>
</ul>
<h3 id="6-2-2-MySqL是否在扫描额外的记录"><a href="#6-2-2-MySqL是否在扫描额外的记录" class="headerlink" title="6.2.2 MySqL是否在扫描额外的记录"></a>6.2.2 MySqL是否在扫描额外的记录</h3><p>最简单的衡量查询开销的三个指标：响应时间，扫描行数，返回行数。</p>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成。</p>
</li>
<li><p>使用索引覆盖扫描（在Extra列中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。服务层完成。无须再回表查询记录。</p>
</li>
<li><p>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。在服务器层完成。需要先从数据表读出记录，然后过滤。</p>
</li>
</ul>
<p>如果发现查询需要扫描大量的数据，但只返回少数的行，可以</p>
<ul>
<li><p>使用索引覆盖扫描，把所有需要用的列都放到索引中。</p>
</li>
<li><p>改变库表结构。</p>
</li>
<li><p>重写这个复杂的查询。</p>
</li>
</ul>
<h2 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h2><h3 id="6-3-1-一个复杂查询还是多个简单查询"><a href="#6-3-1-一个复杂查询还是多个简单查询" class="headerlink" title="6.3.1 一个复杂查询还是多个简单查询"></a>6.3.1 一个复杂查询还是多个简单查询</h3><h3 id="6-3-2-切分查询"><a href="#6-3-2-切分查询" class="headerlink" title="6.3.2 切分查询"></a>6.3.2 切分查询</h3><p>如将一个大的删除历史数据的查询，切分成每次删除一万条历史数据。而且如果每删除一万条后能暂停一会，可以将压力分散到一个很长的时间多，降低对服务器的影响，大大减少删除时锁的持有时间。</p>
<h3 id="6-3-3-分解关联查询"><a href="#6-3-3-分解关联查询" class="headerlink" title="6.3.3 分解关联查询"></a>6.3.3 分解关联查询</h3><p>对关联查询进行分解，对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。</p>
<p>优势：</p>
<ul>
<li><p>可以让缓存的效率更高。</p>
</li>
<li><p>查询分解后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>在应用层做关联，可以更容易的对数据库进行拆分，更容易做到高性能和可扩展。</p>
</li>
<li><p>查询本身效率也可能会有所提升。</p>
</li>
<li><p>可以减少冗余记录的查询。</p>
</li>
<li><p>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</p>
</li>
</ul>
<h2 id="6-4-查询执行的基础"><a href="#6-4-查询执行的基础" class="headerlink" title="6.4 查询执行的基础"></a>6.4 查询执行的基础</h2><p>1、客户端发送一条查询给服务器。</p>
<p>2、服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。</p>
<p>3、服务器段进行SQL解析，预处理，再由优化器生成对于的执行计划。</p>
<p>4、MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p>
<p>5、将结果返回给客户端。</p>
<h3 id="6-4-1-MySQL客户端-服务器通信协议"><a href="#6-4-1-MySQL客户端-服务器通信协议" class="headerlink" title="6.4.1 MySQL客户端/服务器通信协议"></a>6.4.1 MySQL客户端/服务器通信协议</h3><p>MySQL客户端和服务器之间的通信协议是”半双工”，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，两个动作不能同时发生。</p>
<p>查询状态</p>
<p>对于一个MySQL连接，或者说一个线程，任何时刻都哟一个状态，表示了MySQL当前正在做什么。</p>
<p>可以使用SHOW FULL PROCESSLIST命令（返回结果中的Command列）表示当前状态</p>
<ul>
<li><p>Sleep：线程正在等待客户端发送新的请求。</p>
</li>
<li><p>Query：线程正在执行查询或者正在将结果发送给客户端。</p>
</li>
<li><p>Locked：在MySQL服务器层，该线程正在等待表锁。</p>
</li>
<li><p>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</p>
</li>
<li><p>Copying to tmp table 【on disk】：线程正在执行查询，并且将其结果集都复制到一个临时表中。这种状态要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。<br>如果这个状态后面由on disk标记，表示MySQL正在将一个内存临时表放到磁盘上。</p>
</li>
<li><p>Sorting result：线程正在对结果集进行排序。</p>
</li>
<li><p>Sending data：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p>
</li>
</ul>
<h3 id="6-4-2-查询缓存"><a href="#6-4-2-查询缓存" class="headerlink" title="6.4.2 查询缓存"></a>6.4.2 查询缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。</p>
<p>这个检查是通过一个对大小写敏感的哈希查找实现的。</p>
<p>如果命中，在返回查询结果前，MySqL会检查一次用户权限。无须解析SQL语句，因为缓存中存放了当前查询需要访问的表信息。</p>
<h3 id="6-4-3-查询优化处理"><a href="#6-4-3-查询优化处理" class="headerlink" title="6.4.3 查询优化处理"></a>6.4.3 查询优化处理</h3><p>语法解析器和预处理</p>
<p>MySQL通过关键字将SQL语句进行解析，生成一颗对应的”解析数”。MySQL解析器将使用MySQL语法规则验证和解析查询。</p>
<p>下一步预处理器会验证权限。</p>
<p>查询优化器</p>
<p>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</p>
<p>很多原因会导致优化器选择错误的执行计划：</p>
<ul>
<li><p>统计信息不准确。</p>
</li>
<li><p>执行计划中的成本估算不等同于实际执行的成本。</p>
</li>
<li><p>MySQL的最优可能和你想的最优不一样。</p>
</li>
<li><p>MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</p>
</li>
<li><p>MySQL也并不是任何时候都是基于成本的优化。例如：如果存在全文搜索的MATCH()子句，则在存在全文索引的时候就使用全文索引。</p>
</li>
<li><p>MySQL不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。</p>
</li>
<li><p>有时候优化器无法估算所有可能的执行计划，所以可能错过实际最优执行计划。</p>
</li>
</ul>
<p>优化策略可以简单的分为两种：静态优化和动态优化。</p>
<p>静态优化可以直接对解析树进行分析，并完成优化。可以认为是一种”编译时优化”</p>
<p>动态优化和查询的上下文有关，也可能和很多其他因素有关。可以认为这是”运行时优化”</p>
<p>静态优化只需要做一次，但对查询的动态优化则在每次执行时都需要重新评估，有时甚至在查询的执行过程中也会重新优化。</p>
<p>MySQL能够处理的优化类型：</p>
<ul>
<li><p>重新定义关联表的顺序</p>
</li>
<li><p>将外连接转化成内连接</p>
</li>
<li><p>使用等价变换规则</p>
</li>
<li><p>优化COUNT()，MIN()，MAX()</p>
</li>
<li><p>预估并转化为常数表达式</p>
</li>
<li><p>覆盖索引扫描</p>
</li>
<li><p>子查询优化</p>
</li>
<li><p>提前终止查询</p>
</li>
<li><p>等值传播</p>
</li>
<li><p>列表IN()的比较</p>
</li>
</ul>
<p>数据和索引的统计信息：统计信息由存储引擎实现。</p>
<p>MySQL如何执行关联查询</p>
<p>MySQL认为任何一次查询都是一次”关联”</p>
<p>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。</p>
<p>执行计划</p>
<p>MySQL生成查询的一颗指令树，然后通过存储引擎执行完成这颗指令树并返回结果。最终的执行计划包含了重构查询的全部信息。</p>
<p>关联查询优化器</p>
<p>通常多表关联的时候，可以有多种不同的关联顺序来获取相同的执行结果，关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p>
<p>排序优化</p>
<p>排序是一个成本很高的操作，从性能角度来说，应尽可能避免排序或避免对大量数据排序</p>
<p>除了通过索引进行排序外，当MySQL需要自己进行排序时，数据量小则在内存中，数据量大则在磁盘中。统称为文件排序（filesort）</p>
<p>两种排序方法：</p>
<p>两次传输排序（旧版本使用）：会产生大量随机I/O。</p>
<p>单词传输排序（新版本使用）：无须随机I/O。缺点是如果需要返回的列非常大，会额外占用大量空间。</p>
<p>文件排序需要使用的临时存储空间比想象的要大的多，原因时MySQL会对每一个排序记录分配一个足够大的定长空间来存放。如：VARCHAR则分配完整长度，</p>
<p>关联查询需要排序时，如果ORDER BY子句中所有列都来自关联的第一个表，则在关联处理第一个表 的时候进行文件排序。此时Extra字段会有Using filesort</p>
<p>除此之外，MySQL都会先将关联结果放在一个临时表中，等全部关联结束后，进行文件排序。此时Extra可以看到Using temporary；Using filesort。</p>
<p>而LIMIT也会在排序之后应用。5.6之后有改进，会根据实际情况，选择抛弃不满足条件的结果，在进行排序。</p>
<h3 id="6-4-4-查询执行引擎"><a href="#6-4-4-查询执行引擎" class="headerlink" title="6.4.4 查询执行引擎"></a>6.4.4 查询执行引擎</h3><p>MySQL根据执行计划给出的指令逐步执行。</p>
<p>MySQL在优化阶段就为每个表创建了一个handler实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名，索引统计信息等。</p>
<h3 id="6-4-5-返回结果给客户端"><a href="#6-4-5-返回结果给客户端" class="headerlink" title="6.4.5 返回结果给客户端"></a>6.4.5 返回结果给客户端</h3><p>查询执行的最后一个阶段就是将结果返回给客户端，即使查询不需要返回结果集，也会返回这个查询的一些信息，如查询影响行数。</p>
<p>如果查询可以被缓存，则在这个阶段将结果放在查询缓存中。</p>
<p>返回是一个增量，逐步返回的过程，当开始生成第一条结果时，就可以开始向客户端逐步返回了。</p>
<p>好处是：服务器端无须存储太多的结果，另外可以让客户端第一时间获得返回结果。</p>
<h2 id="6-5-MySQL查询优化器的局限性"><a href="#6-5-MySQL查询优化器的局限性" class="headerlink" title="6.5 MySQL查询优化器的局限性"></a>6.5 MySQL查询优化器的局限性</h2><h3 id="6-5-1-关联子查询"><a href="#6-5-1-关联子查询" class="headerlink" title="6.5.1 关联子查询"></a>6.5.1 关联子查询</h3><p>MySQL的子查询实现得非常糟糕。最糟糕的一类查询是WHERE条件中包换IN（）的子查询语句。</p>
<p>如果用好关联子查询：</p>
<pre><code>并不是所有关联子查询的性能都会很差，需要测试来验证。
</code></pre><h3 id="6-5-2-UNION的限制"><a href="#6-5-2-UNION的限制" class="headerlink" title="6.5.2 UNION的限制"></a>6.5.2 UNION的限制</h3><p>当UNION两个子查询，在从结果中取出前20条时，这个查询会将两个子查询结果放在一个临时表中，再从临时表中取出20条记录。</p>
<p>可以在两个子查询中分别加上LIMIT 20来减少临时表的数据。</p>
<h3 id="6-5-3-索引合并优化"><a href="#6-5-3-索引合并优化" class="headerlink" title="6.5.3 索引合并优化"></a>6.5.3 索引合并优化</h3><p>前面提到过，当where子句中包含多个复杂条件时，MySQL能够访问单表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p>
<h3 id="6-5-4-等值传递"><a href="#6-5-4-等值传递" class="headerlink" title="6.5.4 等值传递"></a>6.5.4 等值传递</h3><p>等值传递会带来一些意想不到的额外消耗。</p>
<h3 id="6-5-5-并行执行"><a href="#6-5-5-并行执行" class="headerlink" title="6.5.5 并行执行"></a>6.5.5 并行执行</h3><p>MySQL无法利用多核特性来并行执行查询。</p>
<h3 id="6-5-6-哈希关联"><a href="#6-5-6-哈希关联" class="headerlink" title="6.5.6 哈希关联"></a>6.5.6 哈希关联</h3><p>MySQL并不支持哈希关联（当时）</p>
<h3 id="6-5-7-松散索引扫描"><a href="#6-5-7-松散索引扫描" class="headerlink" title="6.5.7 松散索引扫描"></a>6.5.7 松散索引扫描</h3><p>MySQl不支持松散索引扫描，即无法按照一个不连续的方式扫描一个索引。</p>
<h3 id="6-5-8-最大值和最小值优化"><a href="#6-5-8-最大值和最小值优化" class="headerlink" title="6.5.8 最大值和最小值优化"></a>6.5.8 最大值和最小值优化</h3><p>对于MIN()和MAX()查询，MySQL的优化做得并不好。</p>
<h3 id="6-5-9-在同一个表上查询和更新"><a href="#6-5-9-在同一个表上查询和更新" class="headerlink" title="6.5.9 在同一个表上查询和更新"></a>6.5.9 在同一个表上查询和更新</h3><p>MySQL不允许对同一张表同时进行查询和更新。</p>
<h2 id="6-6-查询优化器的提示（hint）"><a href="#6-6-查询优化器的提示（hint）" class="headerlink" title="6.6 查询优化器的提示（hint）"></a>6.6 查询优化器的提示（hint）</h2><p>如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划。</p>
<p>HIGH_PRIORITY和LOW_PRIORITY</p>
<pre><code>当多个语句同时访问某一个表的时候，哪些语句的优先级相对高些，哪些语句的优先级相对低些。

这两个提示只对使用表锁的存储引擎有效。
</code></pre><p>DELAYED</p>
<pre><code>这个提示对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放到缓冲区，在表空闲时批量将数据写入。
</code></pre><p>STRAIGHT_JOIN</p>
<pre><code>可以放置在SELECT语句的SELECT关键字之后，也可以放置在任何两个关联表的名字之间。

第一个用法是让查询中的所有表按照在语句中出现的顺序进行关联。

第二个用法则是固定其前后两个表的关联顺序。
</code></pre><p>SQL_SMALL_RESULT和SQL_BIG_RESULT</p>
<pre><code>这两个提示只对SELECT语句有效。

SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，避免排序操作。

SQL_BIG_RESULT告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作。
</code></pre><p>下略。。。</p>
<pre><code>设置优化器提示很可能会让新版本的优化策略失效。
</code></pre><h2 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h2><h4 id="6-7-1-优化COUNT（）查询"><a href="#6-7-1-优化COUNT（）查询" class="headerlink" title="6.7.1 优化COUNT（）查询"></a>6.7.1 优化COUNT（）查询</h4><p>COUNT（）的作用</p>
<pre><code>它可以统计某个列值的数量，也可以统计行数。
</code></pre><p>关于MyISAM的神话</p>
<pre><code>MyISAM的COUNT（）函数总是非常快，但这有个前提，即只有没有任何WHERE条件的COUNT（*）才非常快。
</code></pre><p>简单的优化</p>
<pre><code>利用MyISAM在count（*）全表非常快这个特性。
</code></pre><p>使用近似值</p>
<pre><code>不要求精准count值时，可以用近似值代替，explain出来的优化器估计行数就是一个不错的近似值。
</code></pre><p>更复杂的优化</p>
<pre><code>通常来说，count()需要扫描大量行，很难优化。&quot;快速，精准和实现简单&quot;，三者永远只能满足其二，必须舍弃其中一个。
</code></pre><h3 id="6-7-2-优化关联查询"><a href="#6-7-2-优化关联查询" class="headerlink" title="6.7.2 优化关联查询"></a>6.7.2 优化关联查询</h3><ul>
<li><p>确保on或者using子句中的列上有索引。</p>
</li>
<li><p>确保任何的group by和order by中的表达式只涉及到一个表中的列。</p>
</li>
<li><p>当升级mysql时，需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。</p>
</li>
</ul>
<h3 id="6-7-3-优化自查询"><a href="#6-7-3-优化自查询" class="headerlink" title="6.7.3 优化自查询"></a>6.7.3 优化自查询</h3><p>尽可能使用关联查询代替（5.6新版本可以忽略）</p>
<h3 id="6-7-4-优化-GROUP-BY-和-DISTINCT"><a href="#6-7-4-优化-GROUP-BY-和-DISTINCT" class="headerlink" title="6.7.4 优化 GROUP BY 和 DISTINCT"></a>6.7.4 优化 GROUP BY 和 DISTINCT</h3><p>都可以使用索引来优化，这也是最有效的优化方式。</p>
<p>优化 GROUP BY WITH ROLLUP </p>
<pre><code>最好的办法时尽可能将 WITH ROLLUP 功能转移到应用程序中处理。
</code></pre><h3 id="6-7-5-优化-LIMIT-分页"><a href="#6-7-5-优化-LIMIT-分页" class="headerlink" title="6.7.5 优化 LIMIT 分页"></a>6.7.5 优化 LIMIT 分页</h3><p>最简单的办法时尽可能使用索引覆盖扫描，而不是查询所有列。然后根据需要做一次关联操作再返回所需的列。</p>
<p>LIMIT 和 OFFSET 的问题，其实是 OFFSET 的问题，它会导致MySQL扫描大量不需要的行，然后丢弃掉。可以利用主键的单调增长，在WHERE条件里加主键判断来优化。</p>
<h3 id="6-7-6-优化-SQL-CALC-FOUND-ROWS"><a href="#6-7-6-优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="6.7.6 优化 SQL_CALC_FOUND_ROWS"></a>6.7.6 优化 SQL_CALC_FOUND_ROWS</h3><p>这个提示会导致不管需不需要，都会扫描所有满足条件的行，再抛弃不需要的行，代价可能非常高。</p>
<h3 id="6-7-7-优化-UNION-查询"><a href="#6-7-7-优化-UNION-查询" class="headerlink" title="6.7.7 优化 UNION 查询"></a>6.7.7 优化 UNION 查询</h3><p>MySQL总是通过创建并填充临时表的方式来执行 UNION 查询。</p>
<p>除非确实需要服务器消除重复的行，否则一定要用 UNION ALL。</p>
<h3 id="6-7-8-静态查询分析"><a href="#6-7-8-静态查询分析" class="headerlink" title="6.7.8 静态查询分析"></a>6.7.8 静态查询分析</h3><p>pt-query-advisor 能够解析查询日志，分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p>
<h3 id="6-7-9-使用用户自定义遍历"><a href="#6-7-9-使用用户自定义遍历" class="headerlink" title="6.7.9 使用用户自定义遍历"></a>6.7.9 使用用户自定义遍历</h3><p>用户自定义遍历是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。</p>
<p>限制：</p>
<ul>
<li><p>使用自定义变量的查询，无法使用查询缓存。</p>
</li>
<li><p>不能在使用常量或者标识符的地方使用自定义变量，例如表名，列名和LIMIT子句中。</p>
</li>
<li><p>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信。</p>
</li>
<li><p>如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</p>
</li>
<li><p>5.0 版本前，大小写敏感。</p>
</li>
<li><p>不能显式地声明自定义变量的类型。</p>
</li>
<li><p>MySQL优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想方式允许。</p>
</li>
<li><p>赋值的顺序和赋值的时间点并不总是固定，依赖于优化器的决定。</p>
</li>
<li><p>赋值符号 := 的优先级非常低，所以赋值表达式应该使用明确的括号。</p>
</li>
<li><p>使用未定义变量不会产生任何语法错误。</p>
</li>
</ul>
<p>优化排名语句</p>
<pre><code>使用用户自定义变量的一个重要特性是可以在给一个变量赋值的同时使用这个变量。
</code></pre><p>避免重复查询刚刚更新的数据</p>
<pre><code>可以使用变量来解决。
</code></pre><p>统计更新和插入数量</p>
<pre><code>当每次由于冲突导致更新时对变量自增一次，然后通过对这个表达式乘以0来让其不影响要更新的内容。
</code></pre><p>确定取值的顺序</p>
<pre><code>一个最常见的问题就是没有注意到在赋值和读取变量的时候可能在查询的不同阶段。
</code></pre><p>编写偷懒的 UNION</p>
<pre><code>略
</code></pre><p>用户自定义变量的其他用处</p>
<p>不仅是在 SELECT 语句中，在其他任何类型的SQL语句中都可以对变量进行赋值。</p>
<p>用法：</p>
<ul>
<li><p>查询运行时计算总数和平均值</p>
</li>
<li><p>模拟GROUP语句中的函数FIRST() 和 LAST()</p>
</li>
<li><p>对大量数据做一些数据计算</p>
</li>
<li><p>计算一个大表的MD5散列值</p>
</li>
<li><p>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0</p>
</li>
<li><p>模拟读/写游标</p>
</li>
<li><p>在 SHOW 语句的 WHERE 子句中加入变量值</p>
</li>
</ul>
<h2 id="6-8-案例学习"><a href="#6-8-案例学习" class="headerlink" title="6.8 案例学习"></a>6.8 案例学习</h2><p>推荐了一本书叫SQL Antipatterns，一本实践型的书籍。</p>
<h3 id="6-8-1-使用MySQL构建一个队列表"><a href="#6-8-1-使用MySQL构建一个队列表" class="headerlink" title="6.8.1 使用MySQL构建一个队列表"></a>6.8.1 使用MySQL构建一个队列表</h3><p>总结：</p>
<ul>
<li><p>尽量少做事，可以的话不要做任何事情</p>
</li>
<li><p>尽可能快地完成需要做的事情，尽量使用UPDATE 代替先 SELECT FOR UPDATE再UPDATE的写法，因为事务提交的速度越快，持有锁的时间就越短。</p>
</li>
<li><p>某些查询是无法优化的。考虑使用不同的查询或者不同的策略去实现相同的目的。</p>
</li>
</ul>
<h3 id="6-8-2-计算两点之间的距离"><a href="#6-8-2-计算两点之间的距离" class="headerlink" title="6.8.2 计算两点之间的距离"></a>6.8.2 计算两点之间的距离</h3><p>优化策略同上</p>
<h3 id="6-8-3-使用用户自定义函数"><a href="#6-8-3-使用用户自定义函数" class="headerlink" title="6.8.3 使用用户自定义函数"></a>6.8.3 使用用户自定义函数</h3><p>编写一个用户自定义函数，通过简单的网络通信协议和一个运行在通用服务器上的后台程序进行交互，并且会外界完全透明。</p>
<h2 id="6-9-总结"><a href="#6-9-总结" class="headerlink" title="6.9 总结"></a>6.9 总结</h2><p>优化通常需要三管齐下：不做，少做，快速地做。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/高性能mysql第五章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/高性能mysql第五章/" itemprop="url">
                  高性能mysql第五章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-18 11:12:37 / Modified: 16:15:36" itemprop="dateCreated datePublished" datetime="2019-11-18T11:12:37+08:00">2019-11-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第5章-创建高性能的索引"><a href="#第5章-创建高性能的索引" class="headerlink" title="第5章 创建高性能的索引"></a>第5章 创建高性能的索引</h1><ul>
<li><p>索引是存储引擎用于快速找到记录的一种数据结构。</p>
</li>
<li><p>索引对良好的性能非常关键。</p>
</li>
<li><p>索引优化是对查询性能优化最有效的手段。</p>
</li>
</ul>
<h2 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h2><p>MySQL先在索引上找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>
<p>索引可以包含一个或多个列的值。多个列时，使用最左前缀原则。</p>
<h3 id="5-1-1-索引的类型"><a href="#5-1-1-索引的类型" class="headerlink" title="5.1.1 索引的类型"></a>5.1.1 索引的类型</h3><p>B-Tree索引（这里的B-Tree是术语，不是真正的B-Tree，实际上很多存储引擎用的是B+Tree）</p>
<p>可以使用B-Tree索引的查询类型：</p>
<ul>
<li>全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另一列，只访问索引的查询</li>
</ul>
<p>B-Tree的限制：</p>
<ul>
<li><p>如果不是按照索引的最左列开始查找，则无法使用索引。</p>
</li>
<li><p>不能跳过索引中的列。</p>
</li>
<li><p>如果查询中有某个列的范围查询，则右边所有列都无法使用索引优化查询。</p>
</li>
</ul>
<p>哈希索引</p>
<ul>
<li><p>基于哈希表实现 ，只有精准匹配所有列的查询才有效</p>
</li>
<li><p>MySQL中，只有Memory引擎显式支持哈希索引。也是Memory引擎表的默认索引。Memory引擎支持非唯一哈希索引，当有多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
</li>
</ul>
<p>限制：</p>
<ul>
<li><p>哈希索引只包含哈希值和行指针，不存储字段值，不能使用索引中的值来避免读取行。不过因为在内存里，影响不大。</p>
</li>
<li><p>无法用于排序</p>
</li>
<li><p>不支持部分索引列匹配查找</p>
</li>
<li><p>只支持等值比较查询，也不支持范围查询</p>
</li>
<li><p>当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐个比较，直到找到符合条件的行</p>
</li>
<li><p>如果哈希冲突很多的话，索引维护操作的代价就会变高。</p>
</li>
</ul>
<p>InnoDB引擎有个特殊功能叫“自适应哈希索引”，当某些索引值被用的非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引。</p>
<p>创建自定义哈希索引：使用键的哈希值，而不是键本身进行索引查找，需要做的就是在查询的where子句中手动指定使用哈希函数。</p>
<p>优点是性能会非常高，缺点是需要维护哈希值。</p>
<p>空间数据索引（R-Tree）</p>
<pre><code>MyISAM支持孔家吗索引。但由于GIS支持并不完善，这个特性很少使用。
</code></pre><p>全文索引</p>
<pre><code>全文索引更类似于搜索引擎做的事。第7章讨论更多细节。
</code></pre><p>其他索引类型</p>
<pre><code>其他第三方存储引擎使用的不同类型数据结构的索引。
</code></pre><h2 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h2><ul>
<li><p>大大减少服务器需要扫描的数据量</p>
</li>
<li><p>可以帮助服务器避免排序和临时表</p>
</li>
<li><p>可以将随机I/O变成顺序I/O</p>
</li>
</ul>
<h2 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h2><h3 id="5-3-1-独立的列"><a href="#5-3-1-独立的列" class="headerlink" title="5.3.1 独立的列"></a>5.3.1 独立的列</h3><pre><code>如果查询中的列不是独立的，是表达式的一部分或函数的参数，则MySQL不会使用索引。
</code></pre><h3 id="5-3-2-前缀索引和索引选择性"><a href="#5-3-2-前缀索引和索引选择性" class="headerlink" title="5.3.2 前缀索引和索引选择性"></a>5.3.2 前缀索引和索引选择性</h3><pre><code>对于BLOB，TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

可以通过COUNT(DISTINCT LEFT(city, 3))/COUNT(*) 来估计用前3位索引是否够用。如果能接近0.031，基本就可以了
</code></pre><h3 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h3><pre><code>多个列上建立单独的索引大部分情况下并不能提高MySQL的查询性能。

5.0版本之后引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定行。

更早的版本只能使用一个单列的索引。

索引合并策略更多时候说明表上索引建的很糟糕。。。
</code></pre><h3 id="5-3-4-选择合适的索引列顺序"><a href="#5-3-4-选择合适的索引列顺序" class="headerlink" title="5.3.4 选择合适的索引列顺序"></a>5.3.4 选择合适的索引列顺序</h3><pre><code>经验法则：将选择性最高的列放在索引最前列。但也需要具体问题具体分析
</code></pre><h3 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>因此无法同时把数据行存放在两个不同的地方，因此一个表只能有一个聚簇索引。</p>
<p>如果没有定义主键，InnoDB会选择一个唯一非空索引代替。如果没有，会隐式定义一个主键。</p>
<p>优点：</p>
<ul>
<li><p>可以把相关数据保存在一起</p>
</li>
<li><p>数据访问更快</p>
</li>
<li><p>使用覆盖索引扫描的查询可以直接使用页结点中的主键值</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>聚簇数据最大限度的提高了I/O密集型应用的性能，但是如果数据都放在内存里，就没什么优势了</p>
</li>
<li><p>插入速度严重依赖于插入顺序。按主键顺序插入是最快的方式，如果不是，加载完成后最好用OPPTIMIZE TABLE命令重新组织下表</p>
</li>
<li><p>变更聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p>
</li>
<li><p>在插入新行，或者主键更新导致需要移动行时，可能面临“页分裂”问题。“页分裂”会导致表占用更多的磁盘空间。</p>
</li>
<li><p>可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续时</p>
</li>
<li><p>二级索引可能比想象的要更大。</p>
</li>
<li><p>二级索引访问需要两次索引查找，而不是一次。</p>
</li>
</ul>
<p>InnoDB和MyISAM的数据分布对比</p>
<p>MyISAM的数据分布：</p>
<ul>
<li><p>MyISAM按照数据插入的顺序存储在磁盘上，每行有对应“行号”，索引的每个叶子结点包含“行号”</p>
</li>
<li><p>其他索引和逐渐索引没有什么区别</p>
</li>
</ul>
<p>InnoDB的数据分布：</p>
<ul>
<li><p>使用聚簇索引，主键索引在每个叶子结点都包含了主键值，事务ID，用户事务和MVCC的回滚指针以及所有的剩余列。</p>
</li>
<li><p>二级索引的叶子结点存储的是主键值</p>
</li>
</ul>
<p>在InnoDB表中按主键顺序插入行</p>
<ul>
<li><p>可以定一个与应用无关的使用AUTO_INCREMENT自增列的代理键作为主键。</p>
</li>
<li><p>最好避免随机聚簇索引。</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的征用，主键的上界会成为“热点”，可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制。</p>
</li>
<li><p>可以考虑重新设计表，或者更改innodb_autoinc_lock_mode参数</p>
</li>
</ul>
<h3 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h3><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，就称为覆盖索引。</p>
<p>优点：</p>
<ul>
<li><p>索引条目通常小于数据行大小。</p>
</li>
<li><p>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。</p>
</li>
<li><p>一些存储引擎如MyISAM在内存中只缓存了索引，数据则依赖操作系统来缓存，因此访问数据需要一次系统调用。可能会导致严重的性能问题。</p>
</li>
<li><p>因为InnoDB是聚簇索引，覆盖索引对其特别要偶用，因为可以避免对主键索引的二次查询。</p>
</li>
</ul>
<p>哈希索引，空间索引和全文索引等都不存储索引列的值，无法成为覆盖索引。</p>
<p>当发起一个索引覆盖查询是，在EXPLAIN的Extra列可以看到Using index的信息。</p>
<h3 id="5-3-7-使用索引扫描来做排序"><a href="#5-3-7-使用索引扫描来做排序" class="headerlink" title="5.3.7 使用索引扫描来做排序"></a>5.3.7 使用索引扫描来做排序</h3><p>MySQL有两种生成有序结果的方式，通过排序操作，或者按索引顺序排序。</p>
<p>如果EXPLAIN出来的type列的值是index，则说明使用了索引扫描来做排序。</p>
<p>扫描索引本身很快，但是当不能覆盖查询所需的全部列时，需要回表查询对应行。这基本是随机I/O，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢。</p>
<p>MySQL可以使用同一个索引既满足排序，又用于查找行。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一只，并且所有列的排序方向都一样时，MySqL才能够使用索引对结果进行排序。</p>
<p>ORDER BY子句需要满足索引的最左前缀的要起，否则MySQL都需要执行排序操作，而无法利用索引排序。</p>
<h3 id="5-3-8-压缩（前缀压缩）索引"><a href="#5-3-8-压缩（前缀压缩）索引" class="headerlink" title="5.3.8 压缩（前缀压缩）索引"></a>5.3.8 压缩（前缀压缩）索引</h3><p>MyISAM使用前缀压缩来减少索引大小，从而让更多的索引可以放入内存中。</p>
<p>默认只压缩字符串，但通过参数设置也可以对整数做压缩。</p>
<p>可以在CREATE TABLE语句中指定PACK_KEYS参数来控制索引压缩的方式。</p>
<h3 id="5-3-9-冗余和重复索引"><a href="#5-3-9-冗余和重复索引" class="headerlink" title="5.3.9 冗余和重复索引"></a>5.3.9 冗余和重复索引</h3><p>MySQL允许在相同列上创建多个索引，无论时有意的还是无意的。</p>
<p>应该避免创建重复索引。</p>
<p>大多数情况下不需要冗余索引，应该尽量扩展已有索引。但时如果扩展已有索引会导致其变得太大时，可以考虑冗余索引。</p>
<p>冗余索引和重复索引会导致INSET,UPDATE,DELELTE等操作速度变慢。</p>
<h3 id="5-2-10-未使用的索引"><a href="#5-2-10-未使用的索引" class="headerlink" title="5.2.10 未使用的索引"></a>5.2.10 未使用的索引</h3><p>永远使用不到的索引，建议删除。</p>
<h3 id="5-3-11-索引和锁"><a href="#5-3-11-索引和锁" class="headerlink" title="5.3.11 索引和锁"></a>5.3.11 索引和锁</h3><p>索引可以让查询锁定更少的行。</p>
<p>关于InnoDB，在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）。</p>
<h2 id="5-4-索引案例学习"><a href="#5-4-索引案例学习" class="headerlink" title="5.4 索引案例学习"></a>5.4 索引案例学习</h2><h3 id="5-4-1-支持多种过滤条件"><a href="#5-4-1-支持多种过滤条件" class="headerlink" title="5.4.1 支持多种过滤条件"></a>5.4.1 支持多种过滤条件</h3><h3 id="5-4-2-避免多个范围条件"><a href="#5-4-2-避免多个范围条件" class="headerlink" title="5.4.2 避免多个范围条件"></a>5.4.2 避免多个范围条件</h3><h3 id="5-4-3-优化排序"><a href="#5-4-3-优化排序" class="headerlink" title="5.4.3 优化排序"></a>5.4.3 优化排序</h3><h2 id="5-5-维护索引和表"><a href="#5-5-维护索引和表" class="headerlink" title="5.5 维护索引和表"></a>5.5 维护索引和表</h2><pre><code>三个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。
</code></pre><h3 id="5-5-1-找到并修复损坏的表"><a href="#5-5-1-找到并修复损坏的表" class="headerlink" title="5.5.1 找到并修复损坏的表"></a>5.5.1 找到并修复损坏的表</h3><p>可以尝试允许CHECK TABLE来检查是否发生了表损坏。</p>
<p>使用REPAIR TABLE命令来修复损坏的表。</p>
<p>也可以通过一个不做任何操作的ALERT操作来重建表。</p>
<p>InnoDB一般不会出现损坏。</p>
<h3 id="5-5-2-更新索引统计信息"><a href="#5-5-2-更新索引统计信息" class="headerlink" title="5.5.2 更新索引统计信息"></a>5.5.2 更新索引统计信息</h3><p>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。</p>
<p>第一个是records_in_range（）。MyISAMM会返回精确值，InnoDB会返回估算值。</p>
<p>第二个是info（），该接口会返回各种类型的数据，包括索引的基数（每个键值又多少条记录）</p>
<h3 id="5-5-3-减少索引和数据的碎片"><a href="#5-5-3-减少索引和数据的碎片" class="headerlink" title="5.5.3 减少索引和数据的碎片"></a>5.5.3 减少索引和数据的碎片</h3><p>B-Tree索引可能会碎片化，这会降低查询效率。</p>
<p>根据设计，B-Tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的。</p>
<p>然而如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。</p>
<p>表的数据存储也可能碎片化，并且更加复杂：</p>
<ul>
<li><p>行碎片：数据行被存储在多个地方的多个片段中。</p>
</li>
<li><p>行间碎片：指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。对全表扫描或者聚簇索引扫描有很大影响。</p>
</li>
<li><p>剩余空间碎片：指数据页中有大量的空余空间。会导致服务器读取大量不需要的数据，从而造成浪费。</p>
</li>
</ul>
<p>MyISAM会出现三类碎片化，InnoDB不会出现行碎片，它会移动短小的行并重写到一个片段中。</p>
<p>可以通过OPTIMIZE TABLE或者导出再导入的方式来重写整理数据。</p>
<p>也可以通过一个不做任何操作的ALERT TABLE操作来重建表。</p>
<h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>三个原则：</p>
<ul>
<li><p>单行访问是很慢的，如果服务器从存储中读取了一个数据快只为了获取其中一行，那么就浪费了很多工作。</p>
</li>
<li><p>按顺序访问范围数据是很快的，第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快很多。<br>第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。</p>
</li>
<li><p>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行，这避免了大量的单行访问。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/正则表达式/" itemprop="url">
                  正则表达式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-12 16:15:07 / Modified: 17:18:43" itemprop="dateCreated datePublished" datetime="2019-11-12T16:15:07+08:00">2019-11-12</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。</span><br><span class="line">  </span><br><span class="line">\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</span><br><span class="line">  </span><br><span class="line">\b\w&#123;6&#125;\b 匹配刚好6个字符的单词。</span><br></pre></td></tr></table></figure>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>在字符前加 \ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deerchao\.cn匹配deerchao.cn，C:\\Windows匹配C:\Windows。</span><br></pre></td></tr></table></figure>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows\d+匹配Windows后面跟1个或更多数字</span><br><span class="line">  </span><br><span class="line">^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</span><br></pre></td></tr></table></figure>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>指定一个字符范围:像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p>
<h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p>用 | 把不同的规则分隔开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</span><br><span class="line"></span><br><span class="line">\(0\d&#123;2&#125;\)[- ]?\d&#123;8&#125;|0\d&#123;2&#125;[- ]?\d&#123;8&#125;这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</span><br><span class="line"></span><br><span class="line">\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。</span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>用小括号（）来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;是一个简单的IP地址匹配表达式。</span><br></pre></td></tr></table></figure>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</span><br></pre></td></tr></table></figure>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。</p>
<p>默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>后向引用用于重复搜索前面某个分组匹配的文本。</p>
<p>也可以自己指定子表达式的组名。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>捕获</td>
<td>(exp)</td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td></td>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td></td>
<td>(?:exp)</td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>零宽断言</td>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td></td>
<td>(?!exp)</td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td>(?#comment)</td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。</span><br></pre></td></tr></table></figure>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&apos;m singing while you&apos;re dancing.时，它会匹配sing和danc。</span><br></pre></td></tr></table></figure>
<p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</span><br><span class="line"></span><br><span class="line">(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</span><br></pre></td></tr></table></figure>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\b\w*q(?!u)\w*\b 匹配包含后面不是字母u的字母q的单词。</span><br><span class="line"></span><br><span class="line">\d&#123;3&#125;(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</span><br></pre></td></tr></table></figure>
<p>零宽度负回顾后发断言(?&lt;!exp)，断言此位置的前面不能匹配表达式exp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;![a-z])\d&#123;7&#125;匹配前面不是小写字母的七位数字。</span><br><span class="line"></span><br><span class="line">(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>通过语法(?#comment)来包含注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。</span><br></pre></td></tr></table></figure>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.*b，它将会匹配最长的以a开始，以b结束的字符串。</span><br><span class="line"></span><br><span class="line">a.*?b匹配最短的，以a开始，以b结束的字符串。</span><br></pre></td></tr></table></figure>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IgnoreCase(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td>Multiline(多行模式)</td>
<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td>
</tr>
<tr>
<td>Singleline(单行模式)</td>
<td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td>
</tr>
<tr>
<td>IgnorePatternWhitespace(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>
</tr>
<tr>
<td>ExplicitCapture(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody>
</table>
<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？</p>
<p>答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</p>
<p>事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，<br>然而在指定该选项时，用的还是 Singleline 的首字母 s.</p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?’group’)</td>
<td>把捕获的内容命名为group,并压入堆栈(Stack)</td>
</tr>
<tr>
<td>(?’-group’)</td>
<td>从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</td>
</tr>
<tr>
<td>(?(group)yes&#124;no)</td>
<td>如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</td>
</tr>
<tr>
<td>(?!)</td>
<td>零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配嵌套的&lt;div&gt;标签：&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&apos;Open&apos;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&apos;-Open&apos;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;.</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td>\b</td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>竖向制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode代码中十六进制代码为nnnn的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII控制字符。比如\cC代表Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td>\p{name}</td>
<td>Unicode中命名为name的字符类，例如\p{IsGreek}</td>
</tr>
<tr>
<td>(?&gt;exp)</td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td>(?<x>-<y>exp)</y></x></td>
<td>平衡组</td>
</tr>
<tr>
<td>(?im-nsx:exp)</td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td>(?im-nsx)</td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>(?(exp)yes&#124;no)</td>
<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>
</tr>
<tr>
<td>(?(exp)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>(?(name)yes&#124;no)</td>
<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>
</tr>
<tr>
<td>(?(name)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody>
</table>
<p><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">参考1</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/ELK个人实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/24/ELK个人实践/" itemprop="url">
                  ELK个人实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-24 15:44:52" itemprop="dateCreated datePublished" datetime="2019-10-24T15:44:52+08:00">2019-10-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-11-08 10:41:32" itemprop="dateModified" datetime="2019-11-08T10:41:32+08:00">2019-11-08</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ELK-Stack简介"><a href="#ELK-Stack简介" class="headerlink" title="ELK Stack简介"></a>ELK Stack简介</h1><p>ELK 不是一款软件，而是 Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack。根据 Google Trend 的信息显示，ELK Stack 已经成为目前最流行的集中式日志解决方案。</p>
<h3 id="1-Elasticsearch-为了搜索"><a href="#1-Elasticsearch-为了搜索" class="headerlink" title="1. Elasticsearch - 为了搜索"></a>1. Elasticsearch - 为了搜索</h3><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="noopener">Apache Lucene(TM)</a>的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
<p>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<code>RESTful API</code>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<p>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的<code>RESTful API</code>、各种语言的客户端甚至命令行与之交互。</p>
<p>上手Elasticsearch非常容易。它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。</p>
<p>Elasticsearch在<a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener">Apache 2 license</a>下许可使用，可以免费下载、使用和修改。</p>
<h4 id="存储数据的行为就叫做索引-indexing"><a href="#存储数据的行为就叫做索引-indexing" class="headerlink" title="存储数据的行为就叫做索引(indexing)"></a>存储数据的行为就叫做索引(indexing)</h4><p>在Elasticsearch中，文档归属于一种类型(type)，而这些类型存在于索引(index)中，我们可以画一些简单的对比图来类比传统关系型数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>
<p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。</p>
<blockquote>
<p>小贴士：</p>
</blockquote>
<p>多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。</p>
<p>直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。<br>后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。</p>
<p>第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。</p>
<p>Shay的妻子依旧等待着她的食谱搜索……</p>
<h3 id="2-Logstash-数据收集"><a href="#2-Logstash-数据收集" class="headerlink" title="2. Logstash - 数据收集"></a>2. Logstash - 数据收集</h3><p>Logstash是一款数据收集引擎。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置；</p>
<p>Logstash 项目诞生于 2009 年 8 月 2 日。其作者是世界著名的运维工程师乔丹西塞(JordanSissel)（<br>发布过非常棒的软件打包工具 fpm）</p>
<p>scribed 在 2011 年进入半死不活的状态，大大激发了其他各种开源日志收集处理框架的蓬勃发展，Logstash 也从 2011 年开始进入 commit 密集期并延续至今。</p>
<p>2013 年，Logstash 被 Elasticsearch 公司收购，ELK stack 正式成为官方用语。Elasticsearch 本身 也是近两年最受关注的大数据项目之一，三次融资已经超过一亿美元。在 Elasticsearch 开发人员的共同努力下，Logstash 的发布机制，插件架构也愈发科学和合理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line"></span><br><span class="line">elasticsearch 项目开始于 2010 年，其实比 logstash 还晚；</span><br></pre></td></tr></table></figure>
<h3 id="3-Kibana-数据展示"><a href="#3-Kibana-数据展示" class="headerlink" title="3. Kibana - 数据展示"></a>3. Kibana - 数据展示</h3><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。</p>
<p>Kibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 Elasticsearch 的实时数据变化。</p>
<p>搭建 Kibana 非常简单。您可以分分钟完成 Kibana 的安装并开始探索 Elasticsearch 的索引数据 — 没有代码、不需要额外的基础设施。</p>
<h3 id="4-Filebeat-数据搜集"><a href="#4-Filebeat-数据搜集" class="headerlink" title="4. Filebeat - 数据搜集"></a>4. Filebeat - 数据搜集</h3><p>ELK 协议栈的新成员，一个轻量级开源日志文件数据搜集器，基于 Logstash-Forwarder 源代码开发，是对它的替代。在需要采集日志数据的 server 上安装 Filebeat，并指定日志目录或日志文件后，Filebeat 就能读取数据，迅速发送到 Logstash 进行解析，亦或直接发送到 Elasticsearch 进行集中式存储和分析。</p>
<h1 id="ELK-常用架构及使用场景介绍"><a href="#ELK-常用架构及使用场景介绍" class="headerlink" title="ELK 常用架构及使用场景介绍"></a>ELK 常用架构及使用场景介绍</h1><h3 id="最简单架构"><a href="#最简单架构" class="headerlink" title="最简单架构"></a>最简单架构</h3><p>在这种架构中，只有一个 Logstash、Elasticsearch 和 Kibana 实例。Logstash 通过输入插件从多种数据源（比如日志文件、标准输入 Stdin 等）获取数据，再经过滤插件加工数据，然后经 Elasticsearch 输出插件输出到 Elasticsearch，通过 Kibana 展示。详见图 1。</p>
<p>图 1. 最简单架构</p>
<p><img src="/images/image001.png" alt="图1"></p>
<p>这种架构非常简单，使用场景也有限。初学者可以搭建这个架构，了解 ELK 如何工作。</p>
<h3 id="Logstash-作为日志搜集器"><a href="#Logstash-作为日志搜集器" class="headerlink" title="Logstash 作为日志搜集器"></a>Logstash 作为日志搜集器</h3><p>这种架构是对上面架构的扩展，把一个 Logstash 数据搜集节点扩展到多个，分布于多台机器，将解析好的数据发送到 Elasticsearch server 进行存储，最后在 Kibana 查询、生成日志报表等。详见图 2。</p>
<p>图 2. Logstash 作为日志搜索器</p>
<p><img src="/images/image002.png" alt="图2"></p>
<p>这种结构因为需要在各个服务器上部署 Logstash，而它比较消耗 CPU 和内存资源，所以比较适合计算资源丰富的服务器，否则容易造成服务器性能下降，甚至可能导致无法正常工作。</p>
<h3 id="Beats-作为日志搜集器"><a href="#Beats-作为日志搜集器" class="headerlink" title="Beats 作为日志搜集器"></a>Beats 作为日志搜集器</h3><p>这种架构引入 Beats 作为日志搜集器。目前 Beats 包括四种：</p>
<ul>
<li><p>Packetbeat（搜集网络流量数据）；</p>
</li>
<li><p>Topbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；</p>
</li>
<li><p>Filebeat（搜集文件数据）；</p>
</li>
<li><p>Winlogbeat（搜集 Windows 事件日志数据）。</p>
</li>
</ul>
<p>Beats 将搜集到的数据发送到 Logstash，经 Logstash 解析、过滤后，将其发送到 Elasticsearch 存储，并由 Kibana 呈现给用户。详见图 3。</p>
<p>图 3. Beats 作为日志搜集器</p>
<p><img src="/images/image003.png" alt="图3"></p>
<p>这种架构解决了 Logstash 在各服务器节点上占用系统资源高的问题。相比 Logstash，Beats 所占系统的 CPU 和内存几乎可以忽略不计。另外，Beats 和 Logstash 之间支持 SSL/TLS 加密传输，客户端和服务器双向认证，保证了通信安全。</p>
<p>因此这种架构适合对数据安全性要求较高，同时各服务器性能比较敏感的场景。</p>
<h3 id="引入消息队列机制的架构"><a href="#引入消息队列机制的架构" class="headerlink" title="引入消息队列机制的架构"></a>引入消息队列机制的架构</h3><p>到笔者整理本文时，Beats 还不支持输出到消息队列，所以在消息队列前后两端只能是 Logstash 实例。这种架构使用 Logstash 从各个数据源搜集数据，然后经消息队列输出插件输出到消息队列中。目前 Logstash 支持 Kafka、Redis、RabbitMQ 等常见消息队列。然后 Logstash 通过消息队列输入插件从队列中获取数据，分析过滤后经输出插件发送到 Elasticsearch，最后通过 Kibana 展示。详见图 4。</p>
<p>图 4. 引入消息队列机制的架构</p>
<p><img src="/images/image004.png" alt="图4"></p>
<p>这种架构适合于日志规模比较庞大的情况。但由于 Logstash 日志解析节点和 Elasticsearch 的负荷比较重，可将他们配置为集群模式，以分担负荷。引入消息队列，均衡了网络传输，从而降低了网络闭塞，尤其是丢失数据的可能性，但依然存在 Logstash 占用系统资源过多的问题。</p>
<h3 id="基于-Filebeat-架构"><a href="#基于-Filebeat-架构" class="headerlink" title="基于 Filebeat 架构"></a>基于 Filebeat 架构</h3><p>前面提到 Filebeat 已经完全替代了 Logstash-Forwarder 成为新一代的日志采集器，同时鉴于它轻量、安全等特点，越来越多人开始使用它。这个章节将详细讲解如何部署基于 Filebeat 的 ELK 集中式日志解决方案，具体架构见图 5。</p>
<p>图 5. 基于 Filebeat 的 ELK 集群架构</p>
<p><img src="/images/image005.png" alt="图5"></p>
<p>因为免费的 ELK 没有任何安全机制，所以这里使用了 Nginx 作反向代理，避免用户直接访问 Kibana 服务器。加上配置 Nginx 实现简单的用户认证，一定程度上提高安全性。另外，Nginx 本身具有负载均衡的作用，能够提高系统访问性能。</p>
<h1 id="Docker-compose-搭建ELK"><a href="#Docker-compose-搭建ELK" class="headerlink" title="Docker-compose 搭建ELK"></a>Docker-compose 搭建ELK</h1><h3 id="1-docker-compose-yml"><a href="#1-docker-compose-yml" class="headerlink" title="1. docker-compose.yml"></a>1. docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2.2&apos;</span><br><span class="line">services:</span><br><span class="line">  # es-master:</span><br><span class="line">  #   container_name: es-master</span><br><span class="line">  #   hostname: es-master</span><br><span class="line">  #   image: elasticsearch:7.4.0</span><br><span class="line">  #   ports:</span><br><span class="line">  #     - 9200:9200</span><br><span class="line">  #     - 9300:9300</span><br><span class="line">  #   volumes:</span><br><span class="line">  #     - ./elasticsearch/es-master/conf/es-master-single.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span><br><span class="line">  #     - esdatamaster:/usr/share/elasticsearch/data</span><br><span class="line">  #   environment:</span><br><span class="line">  #     - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line"></span><br><span class="line">  es-master:</span><br><span class="line">    image: elasticsearch:7.4.0</span><br><span class="line">    container_name: es-master</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - esdatamaster:/usr/share/elasticsearch/data</span><br><span class="line">      - ./elasticsearch/es-master/conf/es-master.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  es-slave1:</span><br><span class="line">    image: elasticsearch:7.4.0</span><br><span class="line">    container_name: es-slave1</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - esdata01:/usr/share/elasticsearch/data</span><br><span class="line">      - ./elasticsearch/es-slave1/conf/es-slave1.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  es-slave2:</span><br><span class="line">    image: elasticsearch:7.4.0</span><br><span class="line">    container_name: es-slave2</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - esdata02:/usr/share/elasticsearch/data</span><br><span class="line">      - ./elasticsearch/es-slave2/conf/es-slave2.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  elastichd:</span><br><span class="line">    container_name: elastichd</span><br><span class="line">    image: containerize/elastichd</span><br><span class="line">    ports:</span><br><span class="line">      - 9800:9800</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  kibana:</span><br><span class="line">    container_name: kibana</span><br><span class="line">    hostname: kibana</span><br><span class="line">    image: kibana:7.4.0</span><br><span class="line">    ports:</span><br><span class="line">      - 5601:5601</span><br><span class="line">    volumes:</span><br><span class="line">      - ./kibana/conf/kibana.yml:/usr/share/kibana/config/kibana.yml</span><br><span class="line">    environment:</span><br><span class="line">      - elasticsearch.hosts=http://es-master:9200</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  filebeat:</span><br><span class="line">    # 容器名称</span><br><span class="line">    container_name: filebeat</span><br><span class="line">    # 主机名称</span><br><span class="line">    hostname: filebeat</span><br><span class="line">    # 镜像</span><br><span class="line">    image: docker.elastic.co/beats/filebeat:7.4.0</span><br><span class="line">    # 持久化挂载</span><br><span class="line">    volumes:</span><br><span class="line">      - ./filebeat/conf/filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class="line">      # 映射到容器中[作为数据源]</span><br><span class="line">      - ./logs:/home/project/spring-boot-elasticsearch/logs</span><br><span class="line">      - ./filebeat/logs:/usr/share/filebeat/logs</span><br><span class="line">      - ./filebeat/data:/usr/share/filebeat/data</span><br><span class="line">    # 将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</span><br><span class="line">    links:</span><br><span class="line">      - logstash</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">  logstash:</span><br><span class="line">    container_name: logstash</span><br><span class="line">    hostname: logstash</span><br><span class="line">    image: logstash:7.4.0</span><br><span class="line">    volumes:</span><br><span class="line">      # 映射到容器中</span><br><span class="line">      - ./logstash/conf/logstash-filebeat.conf:/usr/share/logstash/pipeline/logstash.conf</span><br><span class="line">      - ./logstash/conf/logstash.yml:/usr/share/logstash/config/logstash.yml</span><br><span class="line">      - ./logstash/logs:/usr/share/logstash/logs</span><br><span class="line">    environment:</span><br><span class="line">      - elasticsearch.hosts=http://es-master:9200</span><br><span class="line">    ports:</span><br><span class="line">      - 5044:5044</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  esdatamaster:</span><br><span class="line">    driver: local</span><br><span class="line">  esdata01:</span><br><span class="line">    driver: local</span><br><span class="line">  esdata02:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  esnet:</span><br></pre></td></tr></table></figure>
<h3 id="2-es-master-single-yml"><a href="#2-es-master-single-yml" class="headerlink" title="2. es-master-single.yml"></a>2. es-master-single.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: &quot;es-cluster&quot;</span><br><span class="line"># 网络绑定</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 设置对外服务的http端口</span><br><span class="line">#http.port: 9200</span><br><span class="line"># 设置节点间交互的tcp端口</span><br><span class="line">#transport.port: 9300</span><br><span class="line"># 单节点模式</span><br><span class="line">discovery.type: &quot;single-node&quot;</span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># 安全认证</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line">#http.cors.allow-headers: &quot;Authorization&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-es-master-yml"><a href="#3-es-master-yml" class="headerlink" title="3. es-master.yml"></a>3. es-master.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"># 节点名称</span><br><span class="line">node.name: es-master</span><br><span class="line"># 是否可以成为master节点</span><br><span class="line">node.master: true</span><br><span class="line"># 是否允许该节点存储数据,默认开启</span><br><span class="line">node.data: false</span><br><span class="line"># 网络绑定</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 设置对外服务的http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"># 设置节点间交互的tcp端口</span><br><span class="line">transport.port: 9300</span><br><span class="line"># 集群发现</span><br><span class="line">discovery.seed_hosts:</span><br><span class="line">  - es-master</span><br><span class="line">  - es-slave1</span><br><span class="line">  - es-slave2</span><br><span class="line"># 手动指定可以成为 mater 的所有节点的 name 或者 ip，这些配置将会在第一次选举中进行计算</span><br><span class="line">cluster.initial_master_nodes:</span><br><span class="line">  - es-master</span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># 安全认证</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line">#http.cors.allow-headers: &quot;Authorization&quot;</span><br><span class="line">bootstrap.memory_lock: true</span><br></pre></td></tr></table></figure>
<h3 id="4-es-slave1-yml"><a href="#4-es-slave1-yml" class="headerlink" title="4. es-slave1.yml"></a>4. es-slave1.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"># 节点名称</span><br><span class="line">node.name: es-slave1</span><br><span class="line"># 是否可以成为master节点</span><br><span class="line">node.master: true</span><br><span class="line"># 是否允许该节点存储数据,默认开启</span><br><span class="line">node.data: true</span><br><span class="line"># 网络绑定</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 设置对外服务的http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"># 设置节点间交互的tcp端口</span><br><span class="line">#transport.port: 9300</span><br><span class="line"># 集群发现</span><br><span class="line">discovery.seed_hosts:</span><br><span class="line">  - es-master</span><br><span class="line">  - es-slave1</span><br><span class="line">  - es-slave2</span><br><span class="line"># 手动指定可以成为 mater 的所有节点的 name 或者 ip，这些配置将会在第一次选举中进行计算</span><br><span class="line">cluster.initial_master_nodes:</span><br><span class="line">  - es-master</span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># 安全认证</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line">#http.cors.allow-headers: &quot;Authorization&quot;</span><br><span class="line">bootstrap.memory_lock: true</span><br></pre></td></tr></table></figure>
<h3 id="5-es-slave2-yml"><a href="#5-es-slave2-yml" class="headerlink" title="5. es-slave2.yml"></a>5. es-slave2.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"># 节点名称</span><br><span class="line">node.name: es-slave2</span><br><span class="line"># 是否可以成为master节点</span><br><span class="line">node.master: true</span><br><span class="line"># 是否允许该节点存储数据,默认开启</span><br><span class="line">node.data: true</span><br><span class="line"># 网络绑定</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 设置对外服务的http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"># 设置节点间交互的tcp端口</span><br><span class="line">#transport.port: 9300</span><br><span class="line"># 集群发现</span><br><span class="line">discovery.seed_hosts:</span><br><span class="line">  - es-master</span><br><span class="line">  - es-slave1</span><br><span class="line">  - es-slave2</span><br><span class="line"># 手动指定可以成为 mater 的所有节点的 name 或者 ip，这些配置将会在第一次选举中进行计算</span><br><span class="line">cluster.initial_master_nodes:</span><br><span class="line">  - es-master</span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># 安全认证</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line">#http.cors.allow-headers: &quot;Authorization&quot;</span><br><span class="line">bootstrap.memory_lock: true</span><br></pre></td></tr></table></figure>
<h3 id="6-logstash-filebeat-conf"><a href="#6-logstash-filebeat-conf" class="headerlink" title="6. logstash-filebeat.conf"></a>6. logstash-filebeat.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    # 来源beats</span><br><span class="line">    beats &#123;</span><br><span class="line">        # 端口</span><br><span class="line">        port =&gt; &quot;5044&quot;</span><br><span class="line">        # ssl配置</span><br><span class="line">        # ssl =&gt; true</span><br><span class="line">        # ssl_certificate_authorities =&gt; [&quot;/etc/pki/tls/certs/filebeat.crt&quot;]</span><br><span class="line">        # ssl_certificate =&gt; &quot;/etc/pki/tls/certs/logstash.crt&quot;</span><br><span class="line">        # ssl_key =&gt; &quot;/etc/pki/tls/private/logstash.key&quot;</span><br><span class="line">        # ssl_verify_mode =&gt; &quot;force_peer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 分析、过滤插件，可以多个</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">        source =&gt; &quot;clientip&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    # 选择elasticsearch</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;http://es-master:9200&quot;]</span><br><span class="line">        index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-logstash-yml"><a href="#7-logstash-yml" class="headerlink" title="7. logstash.yml"></a>7. logstash.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.host: &quot;0.0.0.0&quot;</span><br><span class="line">xpack.monitoring.elasticsearch.hosts: [ &quot;http://es-master:9200&quot; ]</span><br><span class="line">xpack.monitoring.enabled: true</span><br></pre></td></tr></table></figure>
<h3 id="8-filebeat-yml"><a href="#8-filebeat-yml" class="headerlink" title="8. filebeat.yml"></a>8. filebeat.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    # 当前目录下的所有.log文件</span><br><span class="line">    - /home/project/spring-boot-elasticsearch/logs/*.log</span><br><span class="line"></span><br><span class="line">  # 多个文件夹</span><br><span class="line">  # prospectors:</span><br><span class="line">  #   - paths:</span><br><span class="line">  #     - /home/project/spring-boot-elasticsearch/logs/*.log</span><br><span class="line">  #   - paths:</span><br><span class="line">  #     - /home/project/spring-boot-elasticsearch/logs/*.log</span><br><span class="line"></span><br><span class="line">  multiline.pattern: ^\[</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line"></span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">  reload.enabled: false</span><br><span class="line"></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 1</span><br><span class="line"></span><br><span class="line">setup.dashboards.enabled: false</span><br><span class="line"></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: &quot;http://kibana:5601&quot;</span><br><span class="line"></span><br><span class="line"># 不直接传输至ES</span><br><span class="line">#output.elasticsearch:</span><br><span class="line"># hosts: [&quot;http://es-master:9200&quot;]</span><br><span class="line"># index: &quot;filebeat-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;logstash:5044&quot;]</span><br><span class="line"></span><br><span class="line">processors:</span><br><span class="line">  - add_host_metadata: ~</span><br><span class="line">  - add_cloud_metadata: ~</span><br></pre></td></tr></table></figure>
<h3 id="9-kibana-yml"><a href="#9-kibana-yml" class="headerlink" title="9. kibana.yml"></a>9. kibana.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务端口</span><br><span class="line">server.port: 5601</span><br><span class="line"># 服务IP</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line"># ES</span><br><span class="line">elasticsearch.hosts: [&quot;http://es-master:9200&quot;]</span><br><span class="line"># 汉化</span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br></pre></td></tr></table></figure>
<h2 id="ES集群内原理"><a href="#ES集群内原理" class="headerlink" title="ES集群内原理"></a>ES集群内原理</h2><p>图 6. 拥有一个索引的单节点集群</p>
<p><img src="/images/image006.png" alt="图6"></p>
<p>图 7. 拥有两个节点的集群——所有主分片和副本分片都已被分配</p>
<p><img src="/images/image007.png" alt="图7"></p>
<p>图 8. 拥有三个节点的集群——为了分散负载而对分片进行重新分配</p>
<p><img src="/images/image008.png" alt="图8"></p>
<p>图 9. 将参数 number_of_replicas 调大到 2</p>
<p><img src="/images/image009.png" alt="图9"></p>
<p>图 10. 关闭了一个节点后的集群</p>
<p><img src="/images/image010.png" alt="图10"></p>
<h2 id="ES部分接口"><a href="#ES部分接口" class="headerlink" title="ES部分接口"></a>ES部分接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/_cat/health</span><br><span class="line"></span><br><span class="line">http://localhost:9200/_cluster/health</span><br><span class="line"></span><br><span class="line">http://localhost:9200/_cluster/allocation/explain</span><br></pre></td></tr></table></figure>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ul>
<li>cpu跑满</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker加配置</span><br></pre></td></tr></table></figure>
<ul>
<li>data文件夹挂载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清理data文件夹</span><br></pre></td></tr></table></figure>
<ul>
<li>es status 406 error</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:9200/tracy/fulltext/_mapping -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;content&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">                &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;&apos;</span><br><span class="line"></span><br><span class="line">6.0版本以后</span><br><span class="line">-H &quot;Content-Type: application/json&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>es单点模式索引未分配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改成集群模式可破</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/nginx常见配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaoxianzhuang">
      <meta itemprop="description" content="where is this place ?">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/06/08/B16107490.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二遥的破碎维度">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/nginx常见配置/" itemprop="url">
                  nginx常见配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-21 14:48:25 / Modified: 16:15:22" itemprop="dateCreated datePublished" datetime="2018-09-21T14:48:25+08:00">2018-09-21</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx常用配置"><a href="#Nginx常用配置" class="headerlink" title="Nginx常用配置"></a>Nginx常用配置</h1><p>包括：动静分离、缓存设置、负载均衡、反向代理、还有虚拟主机功能。</p>
<h2 id="Nginx启动和关闭"><a href="#Nginx启动和关闭" class="headerlink" title="Nginx启动和关闭"></a>Nginx启动和关闭</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/nginx # 启动</span><br><span class="line">/usr/local/bin/nginx -s reload #平滑重启</span><br><span class="line">/usr/local/etc/nginx/nginx.cnf #配置文件。</span><br></pre></td></tr></table></figure>
<h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><p>大致的分块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main # 全局设置</span><br><span class="line">events &#123; # Nginx工作模式</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">http &#123; # http设置</span><br><span class="line">    ....</span><br><span class="line">    upstream myproject &#123; # 负载均衡服务器设置</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server  &#123; # 主机设置</span><br><span class="line">        ....</span><br><span class="line">        location &#123; # URL匹配</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server  &#123;</span><br><span class="line">        ....</span><br><span class="line">        location &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h3><p>下面是一个main区域，它是一个全局的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user nobody nobody;</span><br><span class="line">worker_processes 2;</span><br><span class="line">error_log /usr/local/var/log/nginx/error.log notice;</span><br><span class="line">pid /usr/local/var/run/nginx/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 1024;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p>
</blockquote>
<blockquote>
<p>worker_processes 来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p>
</blockquote>
<blockquote>
<p>error_log 来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p>
</blockquote>
<blockquote>
<p>pid 来指定进程id的存储文件位置。</p>
</blockquote>
<blockquote>
<p>worker_rlimit_nofile 来指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p>
</blockquote>
<h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><p>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    use kqueue; #mac平台</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>use 用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p>
</blockquote>
<blockquote>
<p>worker_connections 用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients = worker_processes <em> worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes </em> worker_connections / 4。</p>
</blockquote>
<blockquote>
<p>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p>
</blockquote>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log /usr/local/var/log/nginx/access.log  main;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 10;</span><br><span class="line">    #gzip on;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>include</li>
</ol>
<blockquote>
<p>用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p>
</blockquote>
<ol start="2">
<li>default_type</li>
</ol>
<blockquote>
<p>设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载窗口了。</p>
</blockquote>
<ol start="3">
<li>log_format</li>
</ol>
<blockquote>
<p>用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p>
</blockquote>
<p>main的类型日志如下：也可以增删部分参数。</p>
<blockquote>
<p>127.0.0.1 - - [21/Apr/2015:18:09:54 +0800] “GET /index.php HTTP/1.1” 200 87151 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36”</p>
</blockquote>
<ol start="4">
<li>access_log</li>
</ol>
<blockquote>
<p>用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p>
</blockquote>
<ol start="5">
<li>sendfile</li>
</ol>
<blockquote>
<p>用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p>
</blockquote>
<ol start="6">
<li>keepalive_timeout</li>
</ol>
<blockquote>
<p>设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p>
</blockquote>
<h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h3><p>server模块是http的子模块，它用来定一个虚拟主机，我们先讲最基本的配置，这些在后面再讲。我们看一下一个简单的server是如何做的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</span><br><span class="line">    # 全局定义，如果都是这一个目录，这样定义最简单。</span><br><span class="line">    root   /Users/yangyi/www;</span><br><span class="line">    index  index.php index.html index.htm; </span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  usr/local/var/log/host.access.log  main;</span><br><span class="line">    error_log  usr/local/var/log/host.error.log  error;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>server 标志定义虚拟主机开始。</p>
</blockquote>
<blockquote>
<p>listen 用于指定虚拟主机的服务端口。</p>
</blockquote>
<blockquote>
<p>server_name 用来指定IP地址或者域名，多个域名之间用空格分开。</p>
</blockquote>
<blockquote>
<p>root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。</p>
</blockquote>
<blockquote>
<p>index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。</p>
</blockquote>
<blockquote>
<p>charset 用于设置网页的默认编码格式。</p>
</blockquote>
<blockquote>
<p>access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p>
</blockquote>
<h3 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h3><p>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</p>
<p>location根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p>
<ol>
<li>我们先来看这个，设定默认首页和虚拟机目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /Users/yangyi/www;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>location / 表示匹配访问根目录。</p>
</blockquote>
<blockquote>
<p>root 指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p>
</blockquote>
<blockquote>
<p>index 用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p>
</blockquote>
<ol start="2">
<li>location 还有一种方式就是正则匹配</li>
</ol>
<p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /Users/yangyi/www;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。</p>
</blockquote>
<blockquote>
<p>fastcgi_pass 链接的是php-fpm的地址。其他几个参数我们以后再说。</p>
</blockquote>
<blockquote>
<p>location 还有其他用法，等讲到实例的时候，再看吧。</p>
</blockquote>
<h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><p>upstream 模块负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。先学习怎么用，具体的使用实例以后再说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream iyangyi.com&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.12.1:80;</span><br><span class="line">    server 192.168.12.2:80 down;</span><br><span class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</span><br><span class="line">    server 192.168.12.4:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。<br>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p>
<p><em>Nginx的负载均衡模块目前支持4种调度算法：</em></p>
<blockquote>
<p>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</p>
</blockquote>
<blockquote>
<p>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</p>
</blockquote>
<blockquote>
<p>fair（第三方）。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</p>
</blockquote>
<blockquote>
<p>url_hash（第三方）。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</p>
</blockquote>
<p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p>
<blockquote>
<p>down，表示当前的server暂时不参与负载均衡。</p>
</blockquote>
<blockquote>
<p>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</p>
</blockquote>
<blockquote>
<p>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</p>
</blockquote>
<blockquote>
<p>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</p>
</blockquote>
<p><em>注意：当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</em></p>
<h2 id="基于域名的虚拟主机"><a href="#基于域名的虚拟主机" class="headerlink" title="基于域名的虚拟主机"></a>基于域名的虚拟主机</h2><p>假设我们在本地开发有3个项目，分别在hosts里映射到本地的127.0.0.1上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 www.iyangyi.com iyangyi.com</span><br><span class="line">127.0.0.1 api.iyangyi.com</span><br><span class="line">127.0.0.1 admin.iyangyi.com</span><br></pre></td></tr></table></figure>
<p>有这样3个项目，分别对应于web根目录下的3个文件夹，我们用域名对应文件夹名字，这样子好记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Users/yangyi/www/www.iyangyi.com/</span><br><span class="line">/Users/yangyi/www/api.iyangyi.com/</span><br><span class="line">/Users/yangyi/www/admin.iyangyi.com/</span><br></pre></td></tr></table></figure>
<p>每个目录下都有一个index.php文件，都是简单的输入自己的域名。</p>
<p>下面我们就来搭建这3个域名的虚拟主机，很显然，我们要新建3个server来完成。建议将对虚拟主机进行配置的内容写进另外一个文件，然后通过include指令包含进来，这样更便于维护和管理。不会使得这个nginx.conf内容太多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">events &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    ....</span><br><span class="line">    include vhost/www.iyangyi.conf;</span><br><span class="line">    include vhost/api.iyangyi.conf;</span><br><span class="line">    include vhost/admin.iyangyi.conf;</span><br><span class="line">    # 或者用 *.conf  包含</span><br><span class="line">    # include vhost/*.conf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>include：主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度。</p>
<p>既然每一个conf都是一个server，前面已经学习了一个完整的server写的了。下面就开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># www.iyangyi.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.iyangyi.com iyangyi.com;</span><br><span class="line"></span><br><span class="line">    root /Users/yangyi/www/www.iyangyi.com/;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    access_log /usr/local/var/log/nginx/www.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/www.iyangyi.error.log error;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; </span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        include        fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># api.iyangyi.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name api.iyangyi.com;</span><br><span class="line"></span><br><span class="line">    root /Users/yangyi/www/api.iyangyi.com/;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    access_log /usr/local/var/log/nginx/api.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/api.iyangyi.error.log error;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; </span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        include        fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># admin.iyangyi.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name admin.iyangyi.com;</span><br><span class="line"></span><br><span class="line">    root /Users/yangyi/www/admin.iyangyi.com/;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    access_log /usr/local/var/log/nginx/admin.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/admin.iyangyi.error.log error;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000; </span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        include        fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样3个很精简的虚拟域名就搭建好了。重启下nginx，然后打开浏览器访问一下这3个域名，就能看到对应的域名内容了。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><em>Nginx 使用反向代理，主要是使用location模块下的proxy_pass选项。</em></p>
<p>来个最简单的。当我访问 mac 上的nginx 的 centos.iyangyi.com 的内容时候, 就反向代理到虚拟机centos上的 apache 192.168.33.10 的index.html页面。</p>
<p>192.168.33.10 中的html 是很简单的一句输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centos apache2 index.html</span><br></pre></td></tr></table></figure>
<p>在hosts里新加上这个域名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#vi /etc/hosts </span><br><span class="line">127.0.0.1 centos.iyangyi.com</span><br></pre></td></tr></table></figure>
<p>在vhost目录中新建一个conf server：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#centos.iyangyi.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name centos.iyangyi.com;</span><br><span class="line"></span><br><span class="line">    access_log /usr/local/var/log/nginx/centos.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/centos.iyangyi.error.log error;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://192.168.33.10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启下nginx：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>
<p>当然。proxy 还有其他的参数，比如：proxy_set_header 用来设置header头部信息参数转发等，等用了可以仔细看看。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>别被这个名字给吓住了，以为是什么很牛逼的东西的。其实不然。也很简单。</p>
<p>先简单说下负载均衡是干嘛的？举个例子：我们的小网站，刚开始就一台nginx服务器，后来，随着业务量增大，用户增多，一台服务器已经不够用了，我们就又多加了几台服务器。那么这几台服务器如何调度？如何均匀的提供访问？这就是负载均衡。</p>
<p>负载均衡的好处是可以集群多台机器一起工作，并且对外的IP和域名是一样的，外界看起来就好像一台机器一样。</p>
<ol>
<li>基于 weight 权重的负载</li>
</ol>
<p>先来一个最简单的，weight权重的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    server 192.168.33.11 weight=10;</span><br><span class="line">    server 192.168.33.12 weight=10;</span><br><span class="line">    server 192.168.33.13 weight=10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name upstream.iyangyi.com;</span><br><span class="line"></span><br><span class="line">    access_log /usr/local/var/log/nginx/upstream.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/upstream.iyangyi.error.log error;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://webservers;</span><br><span class="line">        proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来继续看几个参数 : max_fails和fail_timeout</p>
<blockquote>
<p><strong>max_fails : </strong>允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</p>
</blockquote>
<blockquote>
<p><strong>fail_timeout : </strong>在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用，进行健康状态检查。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    server 192.168.33.11 weight=10 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.33.12 weight=10 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.33.13 weight=10 max_fails=2 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>down： 表示这台机器暂时不参与负载均衡。相当于注释掉了。</p>
</blockquote>
<blockquote>
<p>backup： 表示这台机器是备用机器，是其他的机器不能用的时候，这台机器才会被使用，俗称备胎</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    server 192.168.33.11 down;</span><br><span class="line">    server 192.168.33.12 weight=10 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.33.13 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>基于 ip_hash 的负载</li>
</ol>
<p>这种分配方式，每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.33.11 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.33.12 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.33.13 down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ip_hash 模式下，最好不要设置weight参数，因为你设置了，就相当于手动设置了，将会导致很多的流量分配不均匀。</p>
</blockquote>
<blockquote>
<p>ip_hash 模式下，backup参数不可用，加了会报错，为啥呢？因为，本身我们的访问就是固定的了，其实，备用已经不管什么作用了。</p>
</blockquote>
<h2 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h2><p>页面缓存也是日常web 开发中很重要的一个环节，对于一些页面，我们可以将其静态化，保存起来，下次请求时候，直接走缓存，而不用去请求反相代理服务器甚至数据库服务了。从而减轻服务器压力。</p>
<p>nginx 也提供了简单而强大的下重定向，反向代理的缓存功能，只需要简单配置下，就能将指定的一个页面缓存起来。它的原理也很简单，就是匹配当前访问的url, hash加密后，去指定的缓存目录找，看有没有，有的话就说明匹配到缓存了。</p>
<p>我们先来看一下一个简单的页面缓存的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server  &#123;</span><br><span class="line">        ....</span><br><span class="line">        location ~ *\.php$ &#123;</span><br><span class="line">            proxy_cache cache_zone; #keys_zone的名字</span><br><span class="line">            proxy_cache_key $host$uri$is_args$args; #缓存规则</span><br><span class="line">            proxy_cache_valid any 1d;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来一步一步说。用到的配置参数，主要是proxy_*前缀的很多配置。</p>
<p>首先需要在http中加入proxy_cache_path 它用来制定缓存的目录以及缓存目录深度制定等。它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>path是用来指定 缓存在磁盘的路径地址。比如：/data/nginx/cache。那以后生存的缓存文件就会存在这个目录下。</p>
</blockquote>
<blockquote>
<p>levels用来指定缓存文件夹的级数，可以是：levels=1, levels=1:1, levels=1:2, levels=1:2:3 可以使用任意的1位或2位数字作为目录结构分割符，如 X, X:X,或 X:X:X 例如: 2, 2:2, 1:1:2，但是最多只能是三级目录。</p>
</blockquote>
<p>那这个里面的数字是什么意思呢。表示取hash值的个数。比如：</p>
<blockquote>
<p>现在根据请求地址localhost/index.php?a=4 用md5进行哈希，得到e0bd86606797639426a92306b1b98ad9</p>
</blockquote>
<blockquote>
<p>levels=1:2 表示建立2级目录，把hash最后1位(9)拿出建一个目录，然后再把9前面的2位(ad)拿来建一个目录, 那么缓存文件的路径就是/data/nginx/cache/9/ad/e0bd86606797639426a92306b1b98ad9</p>
</blockquote>
<blockquote>
<p>以此类推：levels=1:1:2表示建立3级目录，把hash最后1位(9)拿出建一个目录，然后再把9前面的1位(d)建一个目录, 最后把d前面的2位(8a)拿出来建一个目录 那么缓存文件的路径就是/data/nginx/cache/9/d/8a/e0bd86606797639426a92306b1b98ad9</p>
</blockquote>
<p>keys_zone 所有活动的key和元数据存储在共享的内存池中，这个区域用keys_zone参数指定。zone_name指的是共享池的名称，zone_size指的是共享池的大小。注意每一个定义的内存池必须是不重复的路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path  /data/nginx/cache/one  levels=1      keys_zone=one:10m;</span><br><span class="line">proxy_cache_path  /data/nginx/cache/two  levels=2:2    keys_zone=two:100m;</span><br><span class="line">proxy_cache_path  /data/nginx/cache/three  levels=1:1:2  keys_zone=three:1000m;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>inactive 表示指定的时间内缓存的数据没有被请求则被删除，默认inactive为10分钟。inactive=1d 1天。inactive=30m 30分钟。</p>
</blockquote>
<blockquote>
<p>max_size 表示单个文件最大不超过的大小。它被用来删除不活动的缓存和控制缓存大小，当目前缓存的值超出max_size指定的值之后，超过其大小后最少使用数据（LRU替换算法）将被删除。max_size=10g表示当缓存池超过10g就会清除不常用的缓存文件。</p>
</blockquote>
<blockquote>
<p>clean_time 表示每间隔自动清除的时间。clean_time=1m 1分钟清除一次缓存。</p>
</blockquote>
<p>好。说完了这个很重要的参数。我们再来说在server模块里的几个配置参数：</p>
<blockquote>
<p>proxy_cache 用来指定用哪个keys_zone的名字，也就是用哪个目录下的缓存。上面我们指定了三个one, two,three 。比如，我现在想用one 这个缓存目录 : proxy_cache one</p>
</blockquote>
<blockquote>
<p>proxy_cache_key 这个其实蛮重要的，它用来指定生成hash的url地址的格式。根据这个key映射成一个hash值，然后存入到本地文件。proxy_cache_key $host$uri表示无论后面跟的什么参数，都会访问一个文件，不会再生成新的文件。 而如果proxy_cache_key $is_args$args，那么传入的参数 localhost/index.php?a=4 与localhost/index.php?a=44 将映射成两个不同hash值的文件。</p>
</blockquote>
<blockquote>
<p>proxy_cache_key 默认是 “$scheme$host$request_uri”。但是一般我们会把它设置成：$host$uri$is_args$args 一个完整的url路径。</p>
</blockquote>
<blockquote>
<p>proxy_cache_valid 它是用来为不同的http响应状态码设置不同的缓存时间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid  200 302  10m;</span><br><span class="line">proxy_cache_valid  404      1m;</span><br></pre></td></tr></table></figure>
<p>表示为http status code 为200和302的设置缓存时间为10分钟，404代码缓存1分钟。 如果只定义时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 5m;</span><br></pre></td></tr></table></figure>
<p>那么只对代码为200, 301和302的code进行缓存。 同样可以使用any参数任何相响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid  200 302 10m;</span><br><span class="line">proxy_cache_valid  301 1h;</span><br><span class="line">proxy_cache_valid  any 1m; #所有的状态都缓存1小时</span><br></pre></td></tr></table></figure>
<p>好。缓存的基本一些配置讲完了。也大致知道了怎么使用这些参数。现在开始实战！我们启动一台vagrant linux 机器 web1 (192.168.33.11) 用作远程代理机器，就不搞复杂的负载均衡了。</p>
<p>先在Mac本地加一个域名cache.iyangyi.com, 然后按照上面的配置在vhost 下新建一个proxy_cache.iyangyi.conf 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /usr/local/var/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m;</span><br><span class="line">server  &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name cache.iyangyi.com;</span><br><span class="line"> </span><br><span class="line">    access_log /usr/local/var/log/nginx/cache.iyangyi.access.log main;</span><br><span class="line">    error_log /usr/local/var/log/nginx/cache.iyangyi.error.log error;</span><br><span class="line"> </span><br><span class="line">    add_header X-Via $server_addr;</span><br><span class="line">    add_header X-Cache $upstream_cache_status;</span><br><span class="line">   </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">        proxy_cache cache_zone;</span><br><span class="line">        proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">        proxy_cache_valid 200 304 1m;</span><br><span class="line">        proxy_pass http://192.168.33.11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开审核元素或者firebug。看network网络请求选项，我们可以看到，Response Headers，在这里我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X-Cache:MISS</span><br><span class="line">X-Via:127.0.0.1</span><br></pre></td></tr></table></figure>
<p>X-cache 为 MISS 表示未命中，请求被传送到后端。因为是第一次访问，没有缓存，所以肯定是未命中。我们再刷新下，就发现其变成了HIT, 表示命中。它还有其他几种状态：</p>
<blockquote>
<p>MISS 未命中，请求被传送到后端</p>
</blockquote>
<blockquote>
<p>HIT 缓存命中</p>
</blockquote>
<blockquote>
<p>EXPIRED 缓存已经过期请求被传送到后端</p>
</blockquote>
<blockquote>
<p>UPDATING 正在更新缓存，将使用旧的应答</p>
</blockquote>
<blockquote>
<p>STALE 后端将得到过期的应答</p>
</blockquote>
<blockquote>
<p>BYPASS 缓存被绕过了</p>
</blockquote>
<p>我们再去看看缓存文件夹 /usr/local/var/cache里面是否有了文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache git:(master) cd a/13</span><br><span class="line">➜  13 git:(master) ls</span><br><span class="line">5bd1af99bcb0db45c8bd601d9ee9e13a</span><br><span class="line">➜  13 git:(master) pwd</span><br><span class="line">/usr/local/var/cache/a/13</span><br></pre></td></tr></table></figure>
<p>已经生成了缓存文件。</p>
<p>我们在url 后面随便加一个什么参数，看会不会新生成一个缓存文件夹及文件：<a href="http://cache.iyangyi.com/?w=ww55" target="_blank" rel="noopener">http://cache.iyangyi.com/?w=ww55</a> 。因为我们使用的生成规则是全部url转换(proxy_cache_key $host$uri$is_args$args;)</p>
<p>查看 X-cache 为 MISS，再刷新 ，变成HIT。再去看一下缓存文件夹 /usr/local/var/cache。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~cache git:(master) ls</span><br><span class="line"> 4 a</span><br></pre></td></tr></table></figure>
<p>果然又生成了一个4文件夹。</p>
<h2 id="location-正则模块"><a href="#location-正则模块" class="headerlink" title="location 正则模块"></a>location 正则模块</h2><p>这一小节，主要来学习nginx中的URL重写怎么做。url重写模块，主要是在location模块面来实现，我们一点一点的看。</p>
<p>首先看下location 正则匹配的使用。还记得之前是如何用location来定位.php文件的吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000; </span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用~来表示location开启正则匹配, 这样：location ~。还可以用这个来匹配静态资源，缓存它们，设置过期时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|mp3|mp4|swf)&#123;</span><br><span class="line">    expires 15d;</span><br><span class="line">&#125;</span><br><span class="line">location ~ .*\.(css|js)&#123;</span><br><span class="line">    expires 12h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>expires 用来设置HTTP应答中的Expires和Cache-Control的头标时间，来告诉浏览器访问这个静态文件时，不用再去请求服务器，直接从本地缓存读取就可以了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法： expires [time|epoch|max|off]</span><br><span class="line">默认值： expires off</span><br><span class="line">作用域： http, server, location</span><br></pre></td></tr></table></figure>
<p>可以在time值中使用正数或负数。“Expires”头标的值将通过当前系统时间加上您设定的 time 值来获得。可以设置的参数如下：</p>
<blockquote>
<p>epoch 指定“Expires”的值为 1 January, 1970, 00:00:01 GMT。</p>
</blockquote>
<blockquote>
<p>max 指定“Expires”的值为 31 December 2037 23:59:59 GMT，“Cache-Control”的值为10年。</p>
</blockquote>
<blockquote>
<p>-1 指定“Expires”的值为 服务器当前时间 -1s,即永远过期。</p>
</blockquote>
<blockquote>
<p>负数：Cache-Control: no-cache。</p>
</blockquote>
<blockquote>
<p>正数或零：Cache-Control: max-age = #, # 会转换为指定时间的秒数。比如：1d、2h、3m。</p>
</blockquote>
<blockquote>
<p>off 表示不修改“Expires”和“Cache-Control”的值。</p>
</blockquote>
<p>比如再看个例子: 控制图片等过期时间为30天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(gif|jpg|jpeg|png|bmp|ico)$ &#123;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以控制哪一个文件目录的时间，比如控制匹配/resource/或者/mediatorModule/里所有的文件缓存设置到最长时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ /(resource|mediatorModule)/ &#123;</span><br><span class="line">    root    /opt/demo;</span><br><span class="line">    expires max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="URL重写模块"><a href="#URL重写模块" class="headerlink" title="URL重写模块"></a>URL重写模块</h2><p>重写模块与很多模块一起使用。先看一下是怎么用的，看2个例子，然后我们再一点一点讲每个的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">    if ($forbidden) &#123;</span><br><span class="line">        return   403;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($slow) &#123;</span><br><span class="line">        limit_rate  10k;</span><br><span class="line">    &#125;</span><br><span class="line">    rewrite ^/(download/.*)/media/(.*)\..*$  /$1/mp3/$2.mp3 break;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    rewrite ^/bbs/(.*)$ http://192.168.18.201/forum/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面2个例子就是利用rewrite来完成URL重写的。我们慢慢来看它的用法。</p>
<ol>
<li>break</li>
</ol>
<p>break和编程语言中的用法一样，就是跳出某个逻辑。</p>
<blockquote>
<p>语法：break</p>
</blockquote>
<blockquote>
<p>默认值：none</p>
</blockquote>
<blockquote>
<p>使用字段：server, location, if</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子就是在if里面使用break,意思是如果访问的文件名不存在，就跳出。后续会有更多的例子。</p>
<ol start="2">
<li>if</li>
</ol>
<p>if 判断一个条件，如果条件成立，则后面的大括号内的语句将执行，相关配置从上级继承。</p>
<blockquote>
<p>语法：if (condition) { … }</p>
</blockquote>
<blockquote>
<p>默认值：none</p>
</blockquote>
<blockquote>
<p>使用字段：server, location</p>
</blockquote>
<p>可以在判断语句中指定下列值：</p>
<blockquote>
<p>一个变量的名称；不成立的值为：空字符传”“或者一些用“0”开始的字符串。</p>
</blockquote>
<blockquote>
<p>一个使用=或者!=运算符的比较语句。</p>
</blockquote>
<blockquote>
<p>使用符号*和模式匹配的正则表达式：</p>
</blockquote>
<blockquote>
<p>~为区分大小写的匹配。</p>
</blockquote>
<blockquote>
<p>~*不区分大小写的匹配（firefox匹配FireFox）。</p>
</blockquote>
<blockquote>
<p>!和!*意为“不匹配的”。</p>
</blockquote>
<blockquote>
<p>使用-f和!-f检查一个文件是否存在。</p>
</blockquote>
<blockquote>
<p>使用-d和!-d检查一个目录是否存在。</p>
</blockquote>
<blockquote>
<p>使用-e和!-e检查一个文件，目录或者软链接是否存在。</p>
</blockquote>
<blockquote>
<p>使用-x和!-x检查一个文件是否为可执行文件。</p>
</blockquote>
<p>$http_user_agent变量获取浏览器的agent，使用~ 来匹配大小写。用户如果使用的IE 浏览器，就执行if里面的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite  ^(.*)$  /msie/$1  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$request_method变量获取请求的方法，使用=来判断是否等于POST 。如果复合，就执行if 里面的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($request_method = POST ) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$request_filename变量获取请求的文件名，使用!-f来匹配文件，如果不是一个文件名，就执行if 里面的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>return</li>
</ol>
<p>这个指令结束执行配置语句并为客户端返回状态代码，可以使用下列的值：204，400，402-406，408，410, 411, 413, 416与500-504。此外，非标准代码444将关闭连接并且不发送任何的头部。</p>
<blockquote>
<p>语法：return code</p>
</blockquote>
<blockquote>
<p>默认值：none</p>
</blockquote>
<blockquote>
<p>使用字段：server, location, if</p>
</blockquote>
<ol start="4">
<li>rewrite</li>
</ol>
<blockquote>
<p>语法：rewrite regex replacement flag</p>
</blockquote>
<blockquote>
<p>默认值：none</p>
</blockquote>
<blockquote>
<p>使用字段：server, location, if</p>
</blockquote>
<p>rewrite用来重写url,有3个位置：</p>
<blockquote>
<p>regex 表示用来匹配的正则</p>
</blockquote>
<blockquote>
<p>replacement 表示用来替换的</p>
</blockquote>
<blockquote>
<p>flag 是尾部的标记</p>
</blockquote>
<p>flag可以是以下的值：</p>
<blockquote>
<p>last - url重写后，马上发起一个新的请求，再次进入server块，重试location匹配，超过10次匹配不到报500错误，地址栏url不变</p>
</blockquote>
<blockquote>
<p>break - url重写后，直接使用当前资源，不再执行location里余下的语句，完成本次请求，地址栏url不变</p>
</blockquote>
<blockquote>
<p>redirect - 返回302临时重定向，url会跳转，爬虫不会更新url。</p>
</blockquote>
<blockquote>
<p>permanent - 返回301永久重定向。url会跳转。爬虫会更新url。</p>
</blockquote>
<blockquote>
<p>为空 - URL 不会变，但是内容已经变化，也是永久性的重定向。</p>
</blockquote>
<p>上面的正则表达式的一部分可以用圆括号，方便之后按照顺序用$1-$9来引用。</p>
<p>我们来看几个例子：</p>
<blockquote>
<p>需要将/photos/123456重写成/path/to/photos/12/1234/123456.png</p>
</blockquote>
<p>可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite  &quot;/photos/([0-9] &#123;2&#125;)([0-9] &#123;2&#125;)([0-9] &#123;2&#125;)&quot; /path/to/photos/$1/$1$2/$1$2$3.png;</span><br></pre></td></tr></table></figure>
<p>下面是一些简单的常见的重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rewrite ^/js/base.core.v3.js /js/base.core.v3.dev.js redirect;</span><br><span class="line">rewrite ^/js/comment.frame.js /js/comment.frame.dev.js redirect;</span><br><span class="line">rewrite ^/live-static/(.*)$ http://live.bilibili.com/public/$1 last;</span><br></pre></td></tr></table></figure>
<h2 id="配置整理"><a href="#配置整理" class="headerlink" title="配置整理"></a>配置整理</h2><p>在此记录下Nginx服务器nginx.conf的配置文件说明, 部分注释收集与网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"># 运行用户</span><br><span class="line">user www-data;    </span><br><span class="line"># 启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 全局错误日志及PID文件</span><br><span class="line">error_log  /var/log/nginx/error.log;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># 工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    worker_connections 1024; #单个后台worker process进程的最大并发链接数</span><br><span class="line">    # multi_accept on; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    access_log    /var/log/nginx/access.log;</span><br><span class="line"></span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span><br><span class="line">    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line">    #连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    1k;</span><br><span class="line">    large_client_header_buffers  4 4k;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/sites-enabled/*;</span><br><span class="line"></span><br><span class="line">    #设定负载均衡的服务器列表</span><br><span class="line">    upstream mysvr &#123;</span><br><span class="line">        #weigth参数表示权值，权值越高被分配到的几率越大</span><br><span class="line">        #本机上的Squid开启3128端口</span><br><span class="line">        server 192.168.8.1:3128 weight=5;</span><br><span class="line">        server 192.168.8.2:80  weight=1;</span><br><span class="line">        server 192.168.8.3:80  weight=6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen       80;</span><br><span class="line">        #定义使用www.xx.com访问</span><br><span class="line">        server_name  www.xx.com;</span><br><span class="line"></span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs/www.xx.com.access.log  main;</span><br><span class="line"></span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /root;      #定义服务器的默认网站根目录位置</span><br><span class="line">            index index.php index.html index.htm;   #定义首页索引文件的名称</span><br><span class="line"></span><br><span class="line">            fastcgi_pass  www.xx.com;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name; </span><br><span class="line">            include /etc/nginx/fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 /50x.html;  </span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">            root   /root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            root /var/www/virtual/htdocs;</span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root /root;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status            on;</span><br><span class="line">            access_log              on;</span><br><span class="line">            auth_basic              &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file  conf/htpasswd;</span><br><span class="line">        &#125;</span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">        location ~ /\.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #第一个虚拟服务器</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听192.168.8.x的80端口</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.8.x;</span><br><span class="line"></span><br><span class="line">        #对aspx后缀的进行负载均衡请求</span><br><span class="line">        location ~ .*\.aspx$ &#123;</span><br><span class="line">            root   /root;#定义服务器的默认网站根目录位置</span><br><span class="line">            index index.php index.html index.htm;#定义首页索引文件的名称</span><br><span class="line"></span><br><span class="line">            proxy_pass  http://mysvr;#请求转向mysvr 定义的服务器列表</span><br><span class="line"></span><br><span class="line">            #以下是一些反向代理的配置可删除.</span><br><span class="line">            proxy_redirect off;</span><br><span class="line"></span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            client_max_body_size 10m;    #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br><span class="line">            proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Nginx模块"><a href="#Nginx模块" class="headerlink" title="Nginx模块"></a>Nginx模块</h1><p>上面我们已经详细讲解了Nginx常用配置，从中我们已经体会到了，Nginx模块化配置的优点。其中，模块化设计类似于面向对象中的接口类，它增强了nginx源码的可读性、可扩充性和可维护性。</p>
<p>所以，Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。</p>
<h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>Nginx的模块从结构上分为核心模块、基础模块和第三方模块：</p>
<blockquote>
<p>核心模块：HTTP模块、EVENT模块和MAIL模块</p>
</blockquote>
<blockquote>
<p>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块，</p>
</blockquote>
<blockquote>
<p>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。</p>
</blockquote>
<p>Nginx的模块从功能上分为如下三类：</p>
<blockquote>
<p>Core(核心模块)：构建nginx基础服务、管理其他模块。</p>
</blockquote>
<blockquote>
<p>Handlers（处理器模块）：此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。</p>
</blockquote>
<blockquote>
<p>Filters （过滤器模块）：此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。</p>
</blockquote>
<blockquote>
<p>Proxies （代理类模块）：此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。</p>
</blockquote>
<p>Nginx的核心模块主要负责建立nginx服务模型、管理网络层和应用层协议、以及启动针对特定应用的一系列候选模块。其他模块负责分配给web服务器的实际工作：</p>
<blockquote>
<p>(1) 当Nginx发送文件或者转发请求到其他服务器，由Handlers(处理模块)或Proxies（代理类模块）提供服务；</p>
</blockquote>
<blockquote>
<p>(2) 当需要Nginx把输出压缩或者在服务端加一些东西，由Filters(过滤模块)提供服务。</p>
</blockquote>
<h2 id="模块处理"><a href="#模块处理" class="headerlink" title="模块处理"></a>模块处理</h2><ol>
<li>当服务器启动，每个handlers(处理模块)都有机会映射到配置文件中定义的特定位置（location）；如果有多个handlers(处理模块)映射到特定位置时，只有一个会“赢”（说明配置文件有冲突项，应该避免发生）。<br>处理模块以三种形式返回：</li>
</ol>
<blockquote>
<p>OK</p>
</blockquote>
<blockquote>
<p>ERROR</p>
</blockquote>
<blockquote>
<p>或者放弃处理这个请求而让默认处理模块来处理（主要是用来处理一些静态文件，事实上如果是位置正确而真实的静态文件，默认的处理模块会抢先处理）。</p>
</blockquote>
<ol start="2">
<li>如果handlers(处理模块)把请求反向代理到后端的服务器，就变成另外一类的模块：load-balancers（负载均衡模块）。负载均衡模块的配置中有一组后端服务器，当一个HTTP请求过来时，它决定哪台服务器应当获得这个请求。</li>
</ol>
<p><em>Nginx的负载均衡模块采用两种方法：</em></p>
<blockquote>
<p>轮转法，它处理请求就像纸牌游戏一样从头到尾分发；</p>
</blockquote>
<blockquote>
<p>IP哈希法，在众多请求的情况下，它确保来自同一个IP的请求会分发到相同的后端服务器。</p>
</blockquote>
<ol start="3">
<li>如果handlers(处理模块)没有产生错误，filters（过滤模块）将被调用。多个filters（过滤模块）能映射到每个位置，所以（比如）每个请求都可以被压缩成块。它们的执行顺序在编译时决定。<br>filters（过滤模块）是经典的“接力链表（CHAIN OF RESPONSIBILITY）”模型：一个filters（过滤模块）被调用，完成其工作，然后调用下一个filters（过滤模块），直到最后一个filters（过滤模块）。</li>
</ol>
<p>过滤模块链的特别之处在于：</p>
<blockquote>
<p>每个filters（过滤模块）不会等上一个filters（过滤模块）全部完成；</p>
</blockquote>
<blockquote>
<p>它能把前一个过滤模块的输出作为其处理内容；有点像Unix中的流水线；</p>
</blockquote>
<p>过滤模块能以buffer（缓冲区）为单位进行操作，这些buffer一般都是一页（4K）大小，当然你也可以在nginx.conf文件中进行配置。这意味着，比如，模块可以压缩来自后端服务器的响应，然后像流一样的到达客户端，直到整个响应发送完成。</p>
<p>总之，过滤模块链以流水线的方式高效率地向客户端发送响应信息。</p>
<ol start="4">
<li>所以总结下上面的内容，一个典型的HTTP处理周期是这样的：</li>
</ol>
<blockquote>
<p>客户端发送HTTP请求 –&gt;</p>
</blockquote>
<blockquote>
<p>Nginx基于配置文件中的位置选择一个合适的处理模块 -&gt;</p>
</blockquote>
<blockquote>
<p>(如果有)负载均衡模块选择一台后端服务器 –&gt;</p>
</blockquote>
<blockquote>
<p>处理模块进行处理并把输出缓冲放到第一个过滤模块上 –&gt;</p>
</blockquote>
<blockquote>
<p>第一个过滤模块处理后输出给第二个过滤模块 –&gt;</p>
</blockquote>
<blockquote>
<p>然后第二个过滤模块又到第三个 –&gt;</p>
</blockquote>
<blockquote>
<p>依此类推 –&gt; 最后把响应发给客户端。</p>
</blockquote>
<p>Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，<br>而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。<br>通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。<br>handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。</p>
<h1 id="Nginx请求处理"><a href="#Nginx请求处理" class="headerlink" title="Nginx请求处理"></a>Nginx请求处理</h1><p>Nginx在启动时会以daemon形式在后台运行，采用多进程+异步非阻塞IO事件模型来处理各种连接请求。多进程模型包括一个master进程，<br>多个worker进程，一般worker进程个数是根据服务器CPU核数来决定的。master进程负责管理Nginx本身和其他worker进程。</p>
<blockquote>
<p>4个worker进程的父进程都是master进程，表明worker进程都是从父进程fork出来的，并且父进程的ppid为1，表示其为daemon进程。</p>
</blockquote>
<blockquote>
<p>需要说明的是，在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>
</blockquote>
<p>Nginx的每一个Worker进程都管理着大量的线程，真正处理请求业务的是Worker之下的线程。worker进程中有一个ngx_worker_process_cycle()函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个Nginx服务被停止。</p>
<p>worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</p>
<blockquote>
<ol>
<li>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>接收和处理这些事件，如是接收到数据，则产生更高层的 request 对象。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>处理 request 的 header 和 body。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>产生响应，并发送回客户端。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>完成 request 的处理。</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>重新初始化定时器及其他事件。</li>
</ol>
</blockquote>
<h2 id="多进程处理模型"><a href="#多进程处理模型" class="headerlink" title="多进程处理模型"></a>多进程处理模型</h2><p><em>下面来介绍一个请求进来，多进程模型的处理方式：</em></p>
<blockquote>
<p>首先，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p>
</blockquote>
<blockquote>
<p>其次，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p>
</blockquote>
<blockquote>
<p>然后，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p>
</blockquote>
<blockquote>
<p>最后，监听成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p>
</blockquote>
<p>进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个worker进程出现异常退出，其他worker进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样子会提高处理效率，并且开发调试也更容易。</p>
<p>如前文所述，多进程模型+异步非阻塞模型才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p>
<p>worker进程会竞争监听客户端的连接请求：这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠web服务器环境下。</p>
<p>针对这种现象，Nginx采用了一个是否打开accept_mutex选项的值，ngx_accept_disabled标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件。</p>
<blockquote>
<p>ngx_accept_disabled值，nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。</p>
</blockquote>
<blockquote>
<p>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空闲连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p>
</blockquote>
<h2 id="一个简单的HTTP请求"><a href="#一个简单的HTTP请求" class="headerlink" title="一个简单的HTTP请求"></a>一个简单的HTTP请求</h2><p>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段：</p>
<blockquote>
<p>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。</p>
</blockquote>
<blockquote>
<p>处理请求头。</p>
</blockquote>
<blockquote>
<p>处理请求体。</p>
</blockquote>
<blockquote>
<p>如果有的话，调用与此请求（URL 或者 Location）关联的 handler。</p>
</blockquote>
<blockquote>
<p>依次调用各 phase handler 进行处理。</p>
</blockquote>
<p>在建立连接过程中，对于nginx监听到的每个客户端连接，都会将它的读事件的handler设置为ngx_http_init_request函数，这个函数就是请求处理的入口。在处理请求时，主要就是要解析http请求，比如：uri，请求行等，然后再根据请求生成响应。</p>
<p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。</p>
<p>在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p>
<p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler 是与定义在配置文件中的某个 location 相关联的。</p>
<p>一个 phase handler 通常执行以下几项任务：</p>
<blockquote>
<p>获取 location 配置。</p>
</blockquote>
<blockquote>
<p>产生适当的响应。</p>
</blockquote>
<blockquote>
<p>发送 response header。</p>
</blockquote>
<blockquote>
<p>发送 response body。</p>
</blockquote>
<p>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）：</p>
<blockquote>
<p>NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_REWRITE_PHASE: Location请求地址重写阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_CONTENT_PHASE: 内容产生阶段</p>
</blockquote>
<blockquote>
<p>NGX_HTTP_LOG_PHASE: 日志模块处理阶段</p>
</blockquote>
<p>在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4等。</p>
<p><em>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试：</em></p>
<blockquote>
<p>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。</p>
</blockquote>
<blockquote>
<p>如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。</p>
</blockquote>
<blockquote>
<p>如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。</p>
</blockquote>
<blockquote>
<p>如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的.gz文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。</p>
</blockquote>
<blockquote>
<p>请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</p>
</blockquote>
<p>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 fiter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p>
<p><em>这里列举几个常见的 filter 模块，例如：</em></p>
<blockquote>
<p>server-side includes。</p>
</blockquote>
<blockquote>
<p>XSLT filtering。</p>
</blockquote>
<blockquote>
<p>图像缩放之类的。</p>
</blockquote>
<blockquote>
<p>gzip 压缩。</p>
</blockquote>
<p>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</p>
<blockquote>
<p>copy: 将一些需要复制的 buf(文件或者内存)重新复制一份然后交给剩余的 body filter 处理。</p>
</blockquote>
<blockquote>
<p>postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</p>
</blockquote>
<blockquote>
<p>write: 写输出到客户端，实际上是写到连接对应的 socket 上。</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://img.duoziwang.com/2017/06/08/B16107490.jpg"
                alt="yaoxianzhuang" />
            
              <p class="site-author-name" itemprop="name">yaoxianzhuang</p>
              <p class="site-description motion-element" itemprop="description">where is this place ?</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yaoxianzhuang</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
